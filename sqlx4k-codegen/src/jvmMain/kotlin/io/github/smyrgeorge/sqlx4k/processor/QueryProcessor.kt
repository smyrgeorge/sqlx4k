package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

/**
 * Processes @Query annotations on interface functions and generates an implementation class.
 *
 * Rules:
 * - Only interfaces are supported. If the type is not an interface, it is ignored with a warning.
 * - Multiple functions per interface are supported.
 * - If the interface name is "Test", a class named "TheImpl" will be created; otherwise, the
 *   class will be named "<InterfaceName>Impl".
 * - Follows the same config options as TableProcessor: output-package and output-filename.
 * - Does not use KotlinPoet; uses direct OutputStream writing just like TableProcessor.
 */
@Suppress("DuplicatedCode")
class QueryProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver
            .getSymbolsWithAnnotation(QUERY_ANNOTATION)
            .filterIsInstance<KSFunctionDeclaration>()

        if (!symbols.iterator().hasNext()) return emptyList()

        val outputPackage = options[TableProcessor.PACKAGE_OPTION]
            ?: error("Missing ${TableProcessor.PACKAGE_OPTION} option")

        val outputFilename = options[FILENAME_OPTION] ?: "GeneratedRepositories"

        val file: OutputStream = codeGenerator.createNewFile(
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = outputPackage,
            fileName = outputFilename
        )

        file += "// Generated by sqlx4k-codegen\n"
        file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\")\n\n"
        file += "package $outputPackage\n"
        file += "\nimport io.github.smyrgeorge.sqlx4k.Statement\n"

        // Group functions by their containing interface
        val grouped = symbols
            .filter { it.validate() }
            .mapNotNull { fn ->
                val parent = fn.parentDeclaration as? KSClassDeclaration ?: return@mapNotNull null
                parent to fn
            }
            .groupBy({ it.first }, { it.second })

        grouped.forEach { (iface, fns) ->
            if (iface.classKind != ClassKind.INTERFACE) {
                error("@Query is only supported on interface functions (${iface.qualifiedName?.asString()}).")
            }

            // Determine implementation class name
            val implName = iface.name() + "Impl"

            // Emit class header
            file += "\nobject $implName : ${iface.qualifiedName?.asString()} {\n"

            // For each function, generate an override that constructs a Statement from @Query
            fns.forEach { fn ->
                val ann: KSAnnotation = fn.annotations.first { it.name() == QUERY_ANNOTATION_NAME }
                val sqlArg: KSValueArgument = ann.arguments.first { it.name?.asString() == "value" }
                val sql = sqlArg.value as String

                // Build method signature
                val name = fn.simpleName.asString()
                val params = fn.parameters
                val paramSig = params.joinToString { p ->
                    val pName = p.name?.asString() ?: "p"
                    val pType = p.type.resolve().declaration.qualifiedName?.asString()
                        ?: p.type.toString()
                    "$pName: $pType"
                }

                file += "    override suspend fun $name($paramSig): Statement {\n"
                file += "        // language=SQL\n"
                file += "        val statement = Statement.create(\"$sql\")\n"

                // Bind parameters in order
                params.forEachIndexed { index, p ->
                    val pName = p.name?.asString() ?: "p$index"
                    file += "        statement.bind($index, $pName)\n"
                }

                file += "        return statement\n"
                file += "    }\n"
            }

            file += "}\n"
        }

        file.close()

        val unableToProcess = symbols.filterNot { it.validate() }.toList()
        return unableToProcess
    }

    private fun KSAnnotation.name(): String = shortName.asString()
    private fun KSClassDeclaration.name(): String = simpleName.asString()

    operator fun OutputStream.plusAssign(str: String) {
        write(str.toByteArray())
    }

    companion object {
        /**
         * The option key used to specify the output filename for the generated SQL classes.
         */
        const val FILENAME_OPTION = "output-filename"
        const val QUERY_ANNOTATION_NAME = "Query"
        const val QUERY_ANNOTATION = "io.github.smyrgeorge.sqlx4k.annotation.Query"
    }
}
