package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

class TableProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    private val dialect: String = when (options[DIALECT_OPTION]?.lowercase()) {
        "mysql" -> "mysql"
        else -> "generic"
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver
            .getSymbolsWithAnnotation(TypeNames.TABLE_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()

        if (!symbols.iterator().hasNext()) return emptyList()

        val outputPackage = options[PACKAGE_OPTION] ?: error("Missing $PACKAGE_OPTION option")
        val outputFilename = "GeneratedQueries"

        logger.info("sqlx4k-codegen: TableProcessor dialect = $dialect")

        val file: OutputStream = codeGenerator.createNewFile(
            // Make sure to associate the generated file with sources to keep/maintain it across incremental builds.
            // Learn more about incremental processing in KSP from the official docs:
            // https://kotlinlang.org/docs/ksp-incremental.html
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = outputPackage,
            fileName = outputFilename
        )

        file += "// Generated by sqlx4k-codegen (TableProcessor)\n"
        file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\")\n\n"
        file += "package $outputPackage\n\n"
        file += "import ${TypeNames.STATEMENT}\n"

        // Processing each class declaration, annotated with @Function.
        symbols.forEach { it.accept(Visitor(file), Unit) }

        // Remember to close the out stream.
        file.close()

        val unableToProcess = symbols.filterNot { it.validate() }.toList()
        return unableToProcess
    }

    inner class Visitor(private val file: OutputStream) : KSVisitorVoid() {

        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            // Getting the @Table annotation object.
            val table: KSAnnotation = classDeclaration.annotations.first {
                it.qualifiedName() == TypeNames.TABLE_ANNOTATION
            }

            // Getting the 'name' argument object from the @Table.
            val nameArgument: KSValueArgument = table.arguments
                .first { arg -> arg.name?.asString() == "name" }

            // Getting the value of the 'name' argument.
            val tableName = nameArgument.value as String

            // Getting the list of member properties of the annotated class.
            val properties: Sequence<KSPropertyDeclaration> = classDeclaration
                .getAllProperties()
                .filter { it.validate() }

            // Make queries.
            insert(tableName, classDeclaration, properties)
            update(tableName, classDeclaration, properties)
            delete(tableName, classDeclaration, properties)
        }

        /**
         * Generates an SQL insert statement for the provided class declaration and properties.
         *
         * @param clazz The class declaration from which to generate the insert statement.
         * @param table The name of the table into which the data will be inserted.
         * @param props The sequence of properties from the class, which will be filtered
         *                    to include only those that should be inserted.
         */
        private fun insert(
            table: String,
            clazz: KSClassDeclaration,
            props: Sequence<KSPropertyDeclaration>
        ) {
            // Materialize all properties to avoid multiple sequence traversals
            val allProps = props.toList()

            // Find insertable properties.
            val insertProps = allProps.asSequence()
                .filter {
                    val id =
                        it.annotations.find { a ->
                            a.qualifiedName() == TypeNames.ID_ANNOTATION
                        } ?: return@filter true

                    val insert: KSValueArgument = id.arguments.first { a ->
                        a.name?.asString() == INSERT_PROPERTY_NAME
                    }

                    (insert.value as? Boolean) ?: false
                }
                .filter {
                    val column =
                        it.annotations.find { a ->
                            a.qualifiedName() == TypeNames.COLUMN_ANNOTATION
                        } ?: return@filter true

                    val insert: KSValueArgument = column.arguments.first { a ->
                        a.name?.asString() == INSERT_PROPERTY_NAME
                    }

                    (insert.value as? Boolean) ?: true
                }
                .map { it.simpleName() }
                .toList()

            // Returning should explicitly list all properties (snake_case), not table.*
            val returningColumns = allProps.joinToString { it.simpleName().toSnakeCase() }

            file += "\n"
            file += "fun ${clazz.qualifiedName?.asString()}.insert(): Statement {\n"
            file += "    // language=SQL\n"
            file += if (dialect == "mysql") {
                // For MySQL, use LAST_INSERT_ID() since RETURNING is not supported
                val idProp =
                    allProps.find { it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION } }
                if (idProp == null) {
                    logger.warn("MySQL dialect selected but no @Id found on $table. Generating INSERT without fetch.")
                    "    val sql = \"insert into $table(${insertProps.joinToString { it.toSnakeCase() }}) values (${insertProps.joinToString { "?" }});\"\n"
                } else {
                    val idCol = idProp.simpleName().toSnakeCase()
                    "    val sql = \"insert into $table(${insertProps.joinToString { it.toSnakeCase() }}) values (${insertProps.joinToString { "?" }}); select $returningColumns from $table where $idCol = coalesce(nullif(last_insert_id(), 0), ?);\"\n"
                }
            } else {
                "    val sql = \"insert into $table(${insertProps.joinToString { it.toSnakeCase() }}) values (${insertProps.joinToString { "?" }}) returning $returningColumns;\"\n"
            }
            file += "    val statement = Statement.create(sql)\n"
            insertProps.forEachIndexed { index, property ->
                file += "    statement.bind($index, ${property})\n"
            }
            if (dialect == "mysql") {
                val idProp =
                    allProps.find { it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION } }
                if (idProp != null) {
                    file += "    statement.bind(${insertProps.size}, ${idProp.simpleName()})\n"
                }
            }
            file += "    return statement\n"
            file += "}\n"
        }

        /**
         * Generates an SQL update statement for the given class declaration and properties.
         *
         * @param clazz The class declaration from which to generate the update statement.
         * @param table The name of the table to be updated.
         * @param props The sequence of properties from the class, which will be filtered to include
         *                   only those that should be updated.
         */
        private fun update(
            table: String,
            clazz: KSClassDeclaration,
            props: Sequence<KSPropertyDeclaration>
        ) {
            // Materialize all properties to avoid multiple sequence traversals
            val allProps = props.toList()

            val id: KSPropertyDeclaration = allProps.find {
                it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION }
            } ?: run {
                logger.warn("Skipping $table.update() because no property found annotated with @Id.")
                return
            }

            // Find updatable properties.
            val updateProps = allProps.asSequence()
                // Exclude @Id from the update query,
                .filter { it.simpleName() != id.simpleName() }
                .filter {
                    val column = it.annotations.find { a ->
                        a.qualifiedName() == TypeNames.COLUMN_ANNOTATION
                    } ?: return@filter true

                    val update: KSValueArgument = column.arguments.first { a ->
                        a.name?.asString() == UPDATE_PROPERTY_NAME
                    }

                    (update.value as? Boolean) ?: true
                }
                .map { it.simpleName() }
                .toList()

            // Returning should explicitly list all properties (snake_case), not table.*
            val returningColumns = allProps.joinToString { it.simpleName().toSnakeCase() }

            file += "\n"
            file += "fun ${clazz.qualifiedName()}.update(): Statement {\n"
            file += "    // language=SQL\n"
            file += if (dialect == "mysql") {
                "    val sql = \"update $table set ${updateProps.joinToString { p -> "${p.toSnakeCase()} = ?" }} where ${
                    id.simpleName().toSnakeCase()
                } = ?; select $returningColumns from $table where ${id.simpleName().toSnakeCase()} = ?;\"\n"
            } else {
                "    val sql = \"update $table set ${updateProps.joinToString { p -> "${p.toSnakeCase()} = ?" }} where ${
                    id.simpleName().toSnakeCase()
                } = ? returning $returningColumns;\"\n"
            }

            file += "    val statement = Statement.create(sql)\n"
            updateProps.forEachIndexed { index, property ->
                file += "    statement.bind($index, ${property})\n"
            }
            file += "    statement.bind(${updateProps.size}, ${id.simpleName()})\n"
            if (dialect == "mysql") {
                file += "    statement.bind(${updateProps.size + 1}, ${id.simpleName()})\n"
            }
            file += "    return statement\n"
            file += "}\n"
        }

        /**
         * Generates an SQL delete statement for the provided class declaration based on its properties.
         *
         * @param clazz The class declaration from which to generate the delete statement.
         * @param table The name of the table to be deleted from.
         * @param props The sequence of properties from the class, used to identify the primary key.
         */
        private fun delete(
            table: String,
            clazz: KSClassDeclaration,
            props: Sequence<KSPropertyDeclaration>
        ) {
            val id: KSPropertyDeclaration = props.find {
                it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION }
            } ?: run {
                logger.warn("Skipping $table.delete() because no property found annotated with @Id.")
                return
            }

            file += "\n"
            file += "fun ${clazz.qualifiedName()}.delete(): Statement {\n"
            file += "    // language=SQL\n"
            file += "    val sql = \"delete from $table where ${id.simpleName().toSnakeCase()} = ?;\"\n"
            file += "    val statement = Statement.create(sql)\n"
            file += "    statement.bind(0, ${id.simpleName()})\n"
            file += "    return statement\n"
            file += "}\n"
        }
    }

    operator fun OutputStream.plusAssign(str: String): Unit = write(str.toByteArray())
    private fun KSPropertyDeclaration.simpleName(): String = simpleName.getShortName()
    private fun KSClassDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSAnnotation.qualifiedName(): String? = annotationType.resolve().declaration.qualifiedName?.asString()
    private fun String.toSnakeCase(): String {
        val pattern = "(?<=.)[A-Z]".toRegex()
        return replace(pattern, "_$0").lowercase()
    }

    companion object {
        /**
         * Key used to specify the package name for the generated output classes.
         */
        const val PACKAGE_OPTION = "output-package"

        /**
         * The option key used to specify the SQL dialect. Supported: generic (default), mysql
         */
        private const val DIALECT_OPTION = "dialect"

        private const val INSERT_PROPERTY_NAME = "insert"
        private const val UPDATE_PROPERTY_NAME = "update"
    }
}
