package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSValueArgument
import com.google.devtools.ksp.symbol.Modifier
import com.google.devtools.ksp.validate
import io.github.smyrgeorge.sqlx4k.processor.TypeNames.BUILT_IN_TYPES
import io.github.smyrgeorge.sqlx4k.processor.TypeNames.builtInDecoder
import io.github.smyrgeorge.sqlx4k.processor.TypeNames.postgresArrayDecoder
import java.io.OutputStream

class TableProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    private val dialect: Dialect = when (options[DIALECT_OPTION]?.lowercase()) {
        "mysql" -> Dialect.MySQL
        "postgres", "postgresql" -> Dialect.PostgreSQL
        "sqlite" -> Dialect.SQLite
        else -> Dialect.Generic
    }

    private val queryDialect: Dialect = when (dialect) {
        Dialect.MySQL -> Dialect.MySQL
        else -> Dialect.Generic
    }

    private val rowMapperDialect: Dialect = when (dialect) {
        Dialect.MySQL -> Dialect.MySQL
        Dialect.PostgreSQL -> Dialect.PostgreSQL
        else -> Dialect.Generic
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver
            .getSymbolsWithAnnotation(TypeNames.TABLE_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
        if (!symbols.iterator().hasNext()) return emptyList()

        val outputPackage = options[PACKAGE_OPTION] ?: error("Missing $PACKAGE_OPTION option")

        logger.info("sqlx4k-codegen: TableProcessor dialect = $dialect")

        // Processing each class declaration, annotated with @Table.
        symbols.forEach { symbol ->
            val className = symbol.simpleName.asString()
            val file: OutputStream = codeGenerator.createNewFile(
                // Make sure to associate the generated file with sources to keep/maintain it across incremental builds.
                // Learn more about incremental processing in KSP from the official docs:
                // https://kotlinlang.org/docs/ksp-incremental.html
                dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
                packageName = outputPackage,
                fileName = "$className$OUTPUT_FILENAME_SUFFIX"
            )

            file += "// Generated by sqlx4k-codegen (TableProcessor)\n"
            @Suppress("DuplicatedCode")
            file += "//@formatter:off\n"
            file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\", \"SqlDialectInspection\", \"UnusedImport\")\n\n"
            file += "package $outputPackage\n\n"
            file += "import ${TypeNames.RESULT_SET}\n"
            file += "import ${TypeNames.ROW_MAPPER}\n"
            file += "import ${TypeNames.STATEMENT}\n"
            file += "import ${TypeNames.VALUE_ENCODER_REGISTRY}\n"
            file += "import ${TypeNames.SQL_ERROR}\n"
            file += "import io.github.smyrgeorge.sqlx4k.impl.extensions.*\n"
            if (rowMapperDialect == Dialect.PostgreSQL) {
                file += "import io.github.smyrgeorge.sqlx4k.postgres.extensions.*\n"
            }

            processClassDeclaration(file, symbol)

            file.close()
        }

        return symbols.filterNot { it.validate() }.toList()
    }

    /**
     * Processes a class declaration annotated with @Table.
     * Generates CRUD queries and RowMapper for the entity.
     *
     * @param file The output stream to write the generated code.
     * @param classDeclaration The class declaration to process.
     */
    private fun processClassDeclaration(file: OutputStream, classDeclaration: KSClassDeclaration) {
        // Validate that the class is a data class (required for copy() in merge functions)
        if (Modifier.DATA !in classDeclaration.modifiers) {
            error("@Table annotation can only be applied to data classes: ${classDeclaration.qualifiedName?.asString()}")
        }

        // Getting the @Table annotation object.
        val table: KSAnnotation = classDeclaration.annotations.first {
            it.qualifiedName() == TypeNames.TABLE_ANNOTATION
        }

        // Getting the 'name' argument object from the @Table.
        val nameArgument: KSValueArgument = table.arguments
            .first { arg -> arg.name?.asString() == "name" }

        // Getting the value of the 'name' argument.
        val tableName = nameArgument.value as String

        // Getting the list of member properties of the annotated class.
        val properties: Sequence<KSPropertyDeclaration> = classDeclaration
            .getAllProperties()
            .filter { it.validate() }

        // Make queries.
        emitInsert(file, tableName, classDeclaration, properties)
        emitApplyInsertResult(file, classDeclaration, properties)
        emitUpdate(file, tableName, classDeclaration, properties)
        emitApplyUpdateResult(file, classDeclaration, properties)
        emitDelete(file, tableName, classDeclaration, properties)

        // Make batch queries.
        // Batch insert: Supported by PostgreSQL, SQLite, and Generic (requires multi-row INSERT with RETURNING).
        // Batch update: Supported by PostgreSQL and Generic (requires FROM VALUES with RETURNING).
        // Generic dialect: Generates code for all batch operations but may produce SQL syntax errors
        //                  depending on the actual database being used.
        emitBatchInsert(file, tableName, classDeclaration, properties)
        emitApplyBatchInsertResult(file, classDeclaration, properties)
        emitBatchUpdate(file, tableName, classDeclaration, properties)
        emitApplyBatchUpdateResult(file, classDeclaration, properties)

        // Generate RowMapper.
        emitRowMapper(file, classDeclaration, properties)
    }

    /**
     * Generates an SQL insert statement for the provided class declaration and properties.
     *
     * @param file The output stream to write the generated code.
     * @param table The name of the table into which the data will be inserted.
     * @param clazz The class declaration from which to generate the insert statement.
     * @param props The sequence of properties from the class, which will be filtered
     *              to include only those that should be inserted.
     */
    private fun emitInsert(
        file: OutputStream,
        table: String,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        val ctx = prepareInsertContext(clazz, props)
        val (allProps, insertPropDeclarations, insertProps, className, returningColumns) = ctx

        file += "\n"
        file += "/**\n"
        file += " * Creates an INSERT statement for this [$className] entity.\n"
        file += " *\n"
        file += " * Generates a prepared SQL INSERT statement with placeholders for the entity's\n"
        file += " * insertable properties. Properties marked with `@Id(insert = false)` or\n"
        file += " * `@Column(insert = false)` are excluded from the insert.\n"
        file += " *\n"
        file += " * The statement includes a RETURNING clause (or equivalent for MySQL) to fetch\n"
        file += " * the inserted row with any database-generated values.\n"
        file += " *\n"
        file += " * @return A prepared [Statement] with bound values ready for execution\n"
        file += " */\n"
        file += "fun ${clazz.qualifiedName()}.insert(): Statement {\n"
        file += "    // language=SQL\n"
        file += if (queryDialect == Dialect.MySQL) {
            // For MySQL, use LAST_INSERT_ID() since RETURNING is not supported
            val idProp = allProps.find {
                it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION }
            } ?: error("MySQL dialect requires an @Id property for insert() on table: $table")
            val idCol = idProp.simpleName().toSnakeCase()
            "    val sql = \"insert into $table(${insertProps.joinToString { it.toSnakeCase() }}) values (${insertProps.joinToString { "?" }}); select $returningColumns from $table where $idCol = coalesce(nullif(last_insert_id(), 0), ?);\"\n"
        } else {
            "    val sql = \"insert into $table(${insertProps.joinToString { it.toSnakeCase() }}) values (${insertProps.joinToString { "?" }}) returning $returningColumns;\"\n"
        }
        file += "    val statement = Statement.create(sql)\n"
        insertPropDeclarations.forEachIndexed { index, prop ->
            val bindExpr = generateBindExpression(prop)
            file += "    statement.bind($index, $bindExpr)\n"
        }
        if (queryDialect == Dialect.MySQL) {
            // idProp is guaranteed to exist for MySQL (error thrown above if missing)
            val idProp = allProps.first {
                it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION }
            }
            val idBindExpr = generateBindExpression(idProp)
            file += "    statement.bind(${insertProps.size}, $idBindExpr)\n"
        }
        file += "    return statement\n"
        file += "}\n"
    }

    /**
     * Generates a function to merge INSERT result (DB-generated columns) back into the entity.
     *
     * @param file The output stream to write the generated code.
     * @param clazz The class declaration for which to generate the merge function.
     * @param props The sequence of properties from the class.
     */
    private fun emitApplyInsertResult(
        file: OutputStream,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        val className = clazz.qualifiedName() ?: clazz.simpleName.asString()
        val returningProps = findInsertReturningProps(props.toList())
            .ifEmpty { error("RETURNING SQL clause cannot be empty for entity (check that a property marked with @Id exists): $className") }
        emitApplyResultFunction(
            file,
            className,
            returningProps,
            "applyInsertResult",
            "INSERT result (DB-generated columns)"
        )
    }

    /**
     * Generates an SQL update statement for the given class declaration and properties.
     *
     * @param file The output stream to write the generated code.
     * @param table The name of the table to be updated.
     * @param clazz The class declaration from which to generate the update statement.
     * @param props The sequence of properties from the class, which will be filtered to include
     *              only those that should be updated.
     */
    private fun emitUpdate(
        file: OutputStream,
        table: String,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        val ctx = prepareUpdateContext(table, clazz, props) ?: return
        val (allProps, id, updatePropDeclarations, updateProps, className, idName, _) = ctx
        // Get DB-generated columns for RETURNING clause
        val returningColumns = findUpdateReturningProps(allProps)
            .ifEmpty { error("RETURNING SQL clause cannot be empty for entity (check that a property marked with @Id exists): $className") }
            .joinToString { it.simpleName().toSnakeCase() }

        file += "\n"
        file += "/**\n"
        file += " * Creates an UPDATE statement for this [$className] entity.\n"
        file += " *\n"
        file += " * Generates a prepared SQL UPDATE statement with placeholders for the entity's\n"
        file += " * updatable properties. The entity is identified by its @Id property `$idName`.\n"
        file += " * Properties marked with `@Column(update = false)` are excluded from the update.\n"
        file += " *\n"
        file += " * The statement includes a RETURNING clause (or equivalent for MySQL) to fetch\n"
        file += " * the updated row with any modified values.\n"
        file += " *\n"
        file += " * @return A prepared [Statement] with bound values ready for execution\n"
        file += " */\n"
        file += "fun ${clazz.qualifiedName()}.update(): Statement {\n"
        file += "    // language=SQL\n"
        file += if (queryDialect == Dialect.MySQL) {
            "    val sql = \"update $table set ${updateProps.joinToString { p -> "${p.toSnakeCase()} = ?" }} where ${
                id.simpleName().toSnakeCase()
            } = ?; select $returningColumns from $table where ${id.simpleName().toSnakeCase()} = ?;\"\n"
        } else {
            "    val sql = \"update $table set ${updateProps.joinToString { p -> "${p.toSnakeCase()} = ?" }} where ${
                id.simpleName().toSnakeCase()
            } = ? returning $returningColumns;\"\n"
        }

        file += "    val statement = Statement.create(sql)\n"
        updatePropDeclarations.forEachIndexed { index, prop ->
            val bindExpr = generateBindExpression(prop)
            file += "    statement.bind($index, $bindExpr)\n"
        }
        val idBindExpr = generateBindExpression(id)
        file += "    statement.bind(${updateProps.size}, $idBindExpr)\n"
        if (queryDialect == Dialect.MySQL) {
            file += "    statement.bind(${updateProps.size + 1}, $idBindExpr)\n"
        }
        file += "    return statement\n"
        file += "}\n"
    }

    /**
     * Generates a function to merge UPDATE result (DB-generated columns) back into the entity.
     *
     * @param file The output stream to write the generated code.
     * @param clazz The class declaration for which to generate the merge function.
     * @param props The sequence of properties from the class.
     */
    private fun emitApplyUpdateResult(
        file: OutputStream,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        val className = clazz.qualifiedName() ?: clazz.simpleName.asString()
        val returningProps = findUpdateReturningProps(props.toList())
            .ifEmpty { error("RETURNING SQL clause cannot be empty for entity (check that a property marked with @Id exists): $className") }
        emitApplyResultFunction(
            file,
            className,
            returningProps,
            "applyUpdateResult",
            "UPDATE result (DB-generated columns)"
        )
    }

    /**
     * Generates an SQL delete statement for the provided class declaration based on its properties.
     *
     * @param file The output stream to write the generated code.
     * @param table The name of the table to be deleted from.
     * @param clazz The class declaration from which to generate the delete statement.
     * @param props The sequence of properties from the class, used to identify the primary key.
     */
    private fun emitDelete(
        file: OutputStream,
        table: String,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        val id: KSPropertyDeclaration = props.find {
            it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION }
        } ?: run {
            logger.warn("Skipping $table.delete() because no property found annotated with @Id.")
            return
        }

        val className = clazz.qualifiedName() ?: clazz.simpleName.asString()
        val idName = id.simpleName.getShortName()
        file += "\n"
        file += "/**\n"
        file += " * Creates a DELETE statement for this [$className] entity.\n"
        file += " *\n"
        file += " * Generates a prepared SQL DELETE statement that removes the entity\n"
        file += " * from the database. The entity is identified by its @Id property `$idName`.\n"
        file += " *\n"
        file += " * @return A prepared [Statement] with bound values ready for execution\n"
        file += " */\n"
        file += "fun ${clazz.qualifiedName()}.delete(): Statement {\n"
        file += "    // language=SQL\n"
        file += "    val sql = \"delete from $table where ${id.simpleName().toSnakeCase()} = ?;\"\n"
        file += "    val statement = Statement.create(sql)\n"
        val idBindExpr = generateBindExpression(id)
        file += "    statement.bind(0, $idBindExpr)\n"
        file += "    return statement\n"
        file += "}\n"
    }

    /**
     * Generates a batch INSERT statement for the provided class declaration.
     * Supported for PostgreSQL, SQLite, and Generic dialects.
     *
     * @param file The output stream to write the generated code.
     * @param table The name of the table into which the data will be inserted.
     * @param clazz The class declaration from which to generate the batch insert statement.
     * @param props The sequence of properties from the class.
     */
    private fun emitBatchInsert(
        file: OutputStream,
        table: String,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        // Only support PostgreSQL, SQLite, and Generic (not MySQL)
        if (dialect == Dialect.MySQL) return

        val ctx = prepareInsertContext(clazz, props)
        val (_, insertPropDeclarations, insertProps, className, returningColumns) = ctx

        val propsCount = insertProps.size
        val columnNames = insertProps.joinToString { it.toSnakeCase() }
        val singleValuePlaceholder = "(${insertProps.joinToString { "?" }})"

        file += "\n"
        file += "/**\n"
        file += " * Creates a batch INSERT statement for this collection of [$className] entities.\n"
        file += " *\n"
        file += " * Generates a prepared SQL INSERT statement with multiple value rows for batch insertion.\n"
        file += " * Properties marked with `@Id(insert = false)` or `@Column(insert = false)` are excluded.\n"
        file += " *\n"
        file += " * The statement includes a RETURNING clause to fetch the inserted rows with any\n"
        file += " * database-generated values.\n"
        file += " *\n"
        file += " * @return A prepared [Statement] with bound values ready for execution\n"
        file += " * @throws IllegalArgumentException if the collection is empty\n"
        file += " */\n"
        file += "fun Iterable<$className>.insert(): Statement {\n"
        file += "    val items = this.toList()\n"
        file += "    require(items.isNotEmpty()) { \"Cannot create batch insert statement for empty collection\" }\n"
        file += "    val valuePlaceholders = items.indices.joinToString(\", \") { \"$singleValuePlaceholder\" }\n"
        file += "    // language=SQL\n"
        file += $$"    val sql = \"insert into $$table($$columnNames) values $valuePlaceholders returning $$returningColumns;\"\n"
        file += "    val statement = Statement.create(sql)\n"
        file += "    items.forEachIndexed { itemIndex, item ->\n"
        file += "        val offset = itemIndex * $propsCount\n"
        insertPropDeclarations.forEachIndexed { index, prop ->
            val bindExpr = generateBindExpression(prop, "item")
            file += "        statement.bind(offset + $index, $bindExpr)\n"
        }
        file += "    }\n"
        file += "    return statement\n"
        file += "}\n"
    }

    /**
     * Generates a function to merge batch INSERT results back into the entities.
     *
     * @param file The output stream to write the generated code.
     * @param clazz The class declaration for which to generate the merge function.
     * @param props The sequence of properties from the class.
     */
    private fun emitApplyBatchInsertResult(
        file: OutputStream,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        // Only support PostgreSQL, SQLite, and Generic (not MySQL)
        if (dialect == Dialect.MySQL) return

        val className = clazz.qualifiedName() ?: clazz.simpleName.asString()
        val returningProps = findInsertReturningProps(props.toList())
            .ifEmpty { error("RETURNING SQL clause cannot be empty for entity (check that a property marked with @Id exists): $className") }

        emitApplyBatchResultFunction(
            file,
            className,
            returningProps,
            "applyInsertResult",
            "batch INSERT result (DB-generated columns)"
        )
    }

    /**
     * Generates a batch UPDATE statement for the provided class declaration.
     * Supported for PostgreSQL and Generic dialects (requires FROM VALUES with RETURNING).
     *
     * @param file The output stream to write the generated code.
     * @param table The name of the table to be updated.
     * @param clazz The class declaration from which to generate the batch update statement.
     * @param props The sequence of properties from the class.
     */
    private fun emitBatchUpdate(
        file: OutputStream,
        table: String,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        // Only support PostgreSQL and Generic (not MySQL or SQLite)
        if (dialect == Dialect.MySQL || dialect == Dialect.SQLite) return

        val ctx = prepareUpdateContext(table, clazz, props) ?: return
        val (allProps, id, updatePropDeclarations, updateProps, className, idName, idColumn) = ctx

        // Build the VALUES column list: (id, col1, col2, ...)
        val valueColumns = listOf(idColumn) + updateProps.map { it.toSnakeCase() }
        val valueColumnsList = valueColumns.joinToString(", ")
        val propsCount = valueColumns.size
        val singleValuePlaceholder = "(${valueColumns.joinToString { "?" }})"

        file += "\n"
        file += "/**\n"
        file += " * Creates a batch UPDATE statement for this collection of [$className] entities.\n"
        file += " *\n"
        file += " * Generates a prepared SQL UPDATE statement using PostgreSQL's FROM VALUES syntax\n"
        file += " * for efficient batch updates. Each entity is identified by its @Id property `$idName`.\n"
        file += " * Properties marked with `@Column(update = false)` are excluded from the update.\n"
        file += " *\n"
        file += " * The statement includes a RETURNING clause to fetch the updated rows.\n"
        file += " *\n"
        file += " * @return A prepared [Statement] with bound values ready for execution\n"
        file += " * @throws IllegalArgumentException if the collection is empty\n"
        file += " */\n"
        file += "fun Iterable<$className>.update(): Statement {\n"
        file += "    val items = this.toList()\n"
        file += "    require(items.isNotEmpty()) { \"Cannot create batch update statement for empty collection\" }\n"
        file += "    val valuePlaceholders = items.indices.joinToString(\", \") { \"$singleValuePlaceholder\" }\n"

        // PostgreSQL: UPDATE ... FROM (VALUES ...) + RETURNING
        val returningColumns = findUpdateReturningProps(allProps)
            .ifEmpty { error("RETURNING SQL clause cannot be empty for entity (check that a property marked with @Id exists): $className") }
            .joinToString { "t.${it.simpleName().toSnakeCase()}" }
        val setClause = updateProps.joinToString(", ") { p -> "${p.toSnakeCase()} = v.${p.toSnakeCase()}" }

        file += "    // language=SQL\n"
        file += $$"    val sql = \"update $$table as t set $$setClause from (values $valuePlaceholders) as v($$valueColumnsList) where t.$$idColumn = v.$$idColumn returning $$returningColumns;\"\n"

        file += "    val statement = Statement.create(sql)\n"
        file += "    items.forEachIndexed { itemIndex, item ->\n"
        file += "        val offset = itemIndex * $propsCount\n"
        // First bind the ID
        val idBindExpr = generateBindExpression(id, "item")
        file += "        statement.bind(offset + 0, $idBindExpr)\n"
        // Then bind the update properties
        updatePropDeclarations.forEachIndexed { index, prop ->
            val bindExpr = generateBindExpression(prop, "item")
            file += "        statement.bind(offset + ${index + 1}, $bindExpr)\n"
        }
        file += "    }\n"

        file += "    return statement\n"
        file += "}\n"
    }

    /**
     * Generates a function to merge batch UPDATE results back into the entities.
     *
     * @param file The output stream to write the generated code.
     * @param clazz The class declaration for which to generate the merge function.
     * @param props The sequence of properties from the class.
     */
    private fun emitApplyBatchUpdateResult(
        file: OutputStream,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        // Only support PostgreSQL and Generic (not MySQL or SQLite)
        if (dialect == Dialect.MySQL || dialect == Dialect.SQLite) return

        val className = clazz.qualifiedName() ?: clazz.simpleName.asString()
        val returningProps = findUpdateReturningProps(props.toList())
            .ifEmpty { error("RETURNING SQL clause cannot be empty for entity (check that a property marked with @Id exists): $className") }

        emitApplyBatchResultFunction(
            file,
            className,
            returningProps,
            "applyUpdateResult",
            "batch UPDATE result (DB-generated columns)"
        )
    }

    /**
     * Generates a RowMapper implementation for the given class declaration.
     *
     * @param file The output stream to write the generated code.
     * @param clazz The class declaration for which to generate the RowMapper.
     * @param props The sequence of properties from the class.
     */
    private fun emitRowMapper(
        file: OutputStream,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ) {
        val className = clazz.simpleName.asString()
        val qualifiedName = clazz.qualifiedName()
        val mapperName = "${className}AutoRowMapper"

        file += "\n"
        file += "/**\n"
        file += " * Auto-generated RowMapper for [$qualifiedName].\n"
        file += " *\n"
        file += " * Maps database rows to instances of [$qualifiedName] using builtin decoders\n"
        file += " * for standard types and the provided ValueEncoderRegistry for custom types.\n"
        file += " */\n"
        file += "object $mapperName : RowMapper<$qualifiedName> {\n"
        file += "    override fun map(row: ResultSet.Row, converters: ValueEncoderRegistry): $qualifiedName {\n"

        // Generate property mappings
        val properties = props.toList()
        properties.forEach { prop ->
            val propName = prop.simpleName()
            val columnName = propName.toSnakeCase()
            val propType = prop.type.resolve()
            val isNullable = propType.isMarkedNullable

            file += "        val $propName = row.get(\"$columnName\")"
            file += generateDecoder(prop, propType, isNullable)
            file += "\n"
        }

        // Generate the return statement
        file += "        return $qualifiedName(\n"
        properties.forEachIndexed { index, prop ->
            val propName = prop.simpleName()
            val comma = if (index < properties.size - 1) "," else ""
            file += "            $propName = $propName$comma\n"
        }
        file += "        )\n"
        file += "    }\n"
        file += "}\n"
    }

    /**
     * Generates the decoder expression for a property based on its type.
     *
     * @param prop The property declaration.
     * @param propType The resolved type of the property.
     * @param isNullable Whether the type is nullable.
     * @return The decoder expression as a string (e.g., ".asString()", ".asIntOrNull()").
     */
    private fun generateDecoder(
        prop: KSPropertyDeclaration,
        propType: KSType,
        isNullable: Boolean
    ): String {
        val typeQualifiedName = propType.declaration.qualifiedName?.asString()
            ?: error("No type name found for $propType")

        val nullSuffix = if (isNullable) "OrNull" else ""

        // Check for @Converter annotation first - uses 'object' directly (no instantiation)
        val converterAnnotation = prop.getConverterAnnotation()
        if (converterAnnotation != null) {
            validateConverterTypeCompatibility(prop, converterAnnotation)
            val encoderClassName = converterAnnotation.getEncoderClassName()
                ?: error("Cannot get encoder class name from @Converter on property ${prop.simpleName()}")
            return if (isNullable) {
                ".let { col -> if (col.isNull()) null else $encoderClassName.decode(col) }"
            } else {
                ".let { col -> $encoderClassName.decode(col) }"
            }
        }

        // Check for builtin types
        val builtinDecoder = builtInDecoder(typeQualifiedName, nullSuffix)
        if (builtinDecoder != null) {
            return ".$builtinDecoder"
        }

        // Check for PostgreSQL-specific array types
        if (rowMapperDialect == Dialect.PostgreSQL) {
            val postgresArrayDecoder = postgresArrayDecoder(typeQualifiedName, nullSuffix)
            if (postgresArrayDecoder != null) {
                return ".$postgresArrayDecoder"
            }
        }

        // Check if it's an enum
        val declaration = propType.declaration
        if (declaration is KSClassDeclaration && declaration.classKind == ClassKind.ENUM_CLASS) {
            return ".asEnum$nullSuffix<$typeQualifiedName>()"
        }

        // Use custom decoder from registry
        val propName = prop.simpleName()
        return if (isNullable) {
            ".let { col -> if (col.isNull()) null else converters.get<$typeQualifiedName>()?.decode(col) ?: throw SQLError(SQLError.Code.MissingValueConverter, \"No decoder found for type $typeQualifiedName (property: $propName)\") }"
        } else {
            ".let { col -> converters.get<$typeQualifiedName>()?.decode(col) ?: throw SQLError(SQLError.Code.MissingValueConverter, \"No decoder found for type $typeQualifiedName (property: $propName)\") }"
        }
    }

    /**
     * Holds computed context for INSERT operations.
     */
    private data class InsertContext(
        val allProps: List<KSPropertyDeclaration>,
        val insertPropDeclarations: List<KSPropertyDeclaration>,
        val insertProps: List<String>,
        val className: String,
        val returningColumns: String
    )

    /**
     * Prepares the common context needed for INSERT operations.
     *
     * @param clazz The class declaration for which to prepare the insert context.
     * @param props The sequence of properties from the class.
     * @return The computed InsertContext with all necessary values.
     */
    private fun prepareInsertContext(
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ): InsertContext {
        val allProps = props.toList()
        val insertPropDeclarations = findInsertableProps(allProps)
        val insertProps = insertPropDeclarations.map { it.simpleName() }
        val className = clazz.qualifiedName() ?: clazz.simpleName.asString()
        val returningColumns = findInsertReturningProps(allProps)
            .ifEmpty { error("RETURNING SQL clause cannot be empty for entity (check that a property marked with @Id exists): $className") }
            .joinToString { it.simpleName().toSnakeCase() }
        return InsertContext(allProps, insertPropDeclarations, insertProps, className, returningColumns)
    }

    /**
     * Holds computed context for UPDATE operations.
     */
    private data class UpdateContext(
        val allProps: List<KSPropertyDeclaration>,
        val id: KSPropertyDeclaration,
        val updatePropDeclarations: List<KSPropertyDeclaration>,
        val updateProps: List<String>,
        val className: String,
        val idName: String,
        val idColumn: String
    )

    /**
     * Prepares the common context needed for UPDATE operations.
     *
     * @param table The table name (used for warning messages).
     * @param clazz The class declaration for which to prepare the update context.
     * @param props The sequence of properties from the class.
     * @return The computed UpdateContext, or null if no @Id property is found.
     */
    private fun prepareUpdateContext(
        table: String,
        clazz: KSClassDeclaration,
        props: Sequence<KSPropertyDeclaration>
    ): UpdateContext? {
        val allProps = props.toList()
        val id: KSPropertyDeclaration = findIdProperty(allProps) ?: run {
            logger.warn("Skipping $table.update() because no property found annotated with @Id.")
            return null
        }
        val updatePropDeclarations = findUpdatableProps(allProps, id)
        val updateProps = updatePropDeclarations.map { it.simpleName() }
        val className = clazz.qualifiedName() ?: clazz.simpleName.asString()
        val idName = id.simpleName.getShortName()
        val idColumn = id.simpleName().toSnakeCase()
        return UpdateContext(allProps, id, updatePropDeclarations, updateProps, className, idName, idColumn)
    }

    /**
     * Finds the property annotated with @Id.
     *
     * @param allProps All properties of the entity.
     * @return The @Id property, or null if not found.
     */
    private fun findIdProperty(allProps: List<KSPropertyDeclaration>): KSPropertyDeclaration? =
        allProps.find { it.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION } }

    /**
     * Finds properties that should be included in INSERT statements.
     * Excludes properties with @Id(insert = false) or @Column(insert = false).
     *
     * @param allProps All properties of the entity.
     * @return List of insertable property declarations.
     */
    private fun findInsertableProps(allProps: List<KSPropertyDeclaration>): List<KSPropertyDeclaration> =
        allProps.asSequence()
            .filter {
                val id = it.annotations.find { a ->
                    a.qualifiedName() == TypeNames.ID_ANNOTATION
                } ?: return@filter true

                val insert: KSValueArgument? = id.arguments.find { a ->
                    a.name?.asString() == INSERT_PROPERTY_NAME
                }

                (insert?.value as? Boolean) ?: false
            }
            .filter {
                val column = it.annotations.find { a ->
                    a.qualifiedName() == TypeNames.COLUMN_ANNOTATION
                } ?: return@filter true

                val insert: KSValueArgument? = column.arguments.find { a ->
                    a.name?.asString() == INSERT_PROPERTY_NAME
                }

                (insert?.value as? Boolean) ?: true
            }
            .toList()

    /**
     * Finds properties that should be included in UPDATE statements.
     * Excludes the @Id property and properties with @Column(update = false).
     *
     * @param allProps All properties of the entity.
     * @param id The @Id property to exclude.
     * @return List of updatable property declarations.
     */
    private fun findUpdatableProps(
        allProps: List<KSPropertyDeclaration>,
        id: KSPropertyDeclaration
    ): List<KSPropertyDeclaration> =
        allProps.asSequence()
            .filter { it.simpleName() != id.simpleName() }
            .filter {
                val column = it.annotations.find { a ->
                    a.qualifiedName() == TypeNames.COLUMN_ANNOTATION
                } ?: return@filter true

                val update = column.arguments.find { a ->
                    a.name?.asString() == UPDATE_PROPERTY_NAME
                }

                (update?.value as? Boolean) ?: true
            }
            .toList()

    /**
     * Finds properties that INSERT should return (DB-generated columns).
     * These are columns with @Id(insert = false) or @Column(insert = false).
     *
     * @param allProps All properties of the entity.
     * @return List of properties that should be in the RETURNING clause for INSERT.
     */
    private fun findInsertReturningProps(allProps: List<KSPropertyDeclaration>): List<KSPropertyDeclaration> =
        allProps.asSequence()
            .filter { prop ->
                val id = prop.annotations.find { a ->
                    a.qualifiedName() == TypeNames.ID_ANNOTATION
                }
                if (id != null) {
                    // @Id(insert = false) means DB generates the ID
                    val insertArg = id.arguments.find { a -> a.name?.asString() == INSERT_PROPERTY_NAME }
                    return@filter (insertArg?.value as? Boolean) != true
                }

                val column = prop.annotations.find { a ->
                    a.qualifiedName() == TypeNames.COLUMN_ANNOTATION
                }
                if (column != null) {
                    // @Column(insert = false) means DB generates/defaults the value
                    val insertArg = column.arguments.find { a -> a.name?.asString() == INSERT_PROPERTY_NAME }
                    return@filter (insertArg?.value as? Boolean) == false
                }

                false
            }
            .toList()
            .ifEmpty {
                // Fallback: if no generated columns found, use @Id only
                allProps.filter { prop ->
                    prop.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION }
                }
            }

    /**
     * Finds properties that UPDATE should return (DB-generated columns).
     * These are @Id properties and columns with @Column(update = false).
     *
     * @param allProps All properties of the entity.
     * @return List of properties that should be in the RETURNING clause for UPDATE.
     */
    private fun findUpdateReturningProps(allProps: List<KSPropertyDeclaration>): List<KSPropertyDeclaration> =
        allProps.asSequence()
            .filter { prop ->
                // Always include @Id
                if (prop.annotations.any { a -> a.qualifiedName() == TypeNames.ID_ANNOTATION }) {
                    return@filter true
                }

                val column = prop.annotations.find { a ->
                    a.qualifiedName() == TypeNames.COLUMN_ANNOTATION
                }
                if (column != null) {
                    // @Column(update = false) means DB auto-updates this value
                    val updateArg = column.arguments.find { a -> a.name?.asString() == UPDATE_PROPERTY_NAME }
                    return@filter (updateArg?.value as? Boolean) == false
                }

                false
            }
            .toList()

    /**
     * Generates a function to merge result row values back into an entity using copy().
     *
     * @param file The output stream to write the generated code.
     * @param className The fully qualified class name.
     * @param returningProps The properties to include in the copy.
     * @param functionName The name of the generated function.
     * @param docDescription Description for the KDoc.
     */
    private fun emitApplyResultFunction(
        file: OutputStream,
        className: String,
        returningProps: List<KSPropertyDeclaration>,
        functionName: String,
        docDescription: String
    ) {
        if (returningProps.isEmpty()) return

        file += "\n"
        file += "/**\n"
        file += " * Merges the $docDescription back into this [$className] entity.\n"
        file += " *\n"
        file += " * After executing ${if (functionName.contains("Insert")) "an INSERT" else "an UPDATE"} statement, use this function to update the entity\n"
        file += " * with database-generated values (e.g., ${if (functionName.contains("Insert")) "auto-increment ID, default timestamps" else "auto-updated timestamps, version numbers"}).\n"
        file += " *\n"
        file += " * @param row The result row from the statement execution\n"
        file += " * @param converters The registry containing custom type decoders\n"
        file += " * @return A new instance with the generated values merged in\n"
        file += " */\n"
        file += "fun $className.$functionName(row: ResultSet.Row, converters: ValueEncoderRegistry): $className = copy(\n"

        returningProps.forEachIndexed { index, prop ->
            val propName = prop.simpleName()
            val propType = prop.type.resolve()
            val isNullable = propType.isMarkedNullable
            val decoder = generateDecoder(prop, propType, isNullable)
            val comma = if (index < returningProps.size - 1) "," else ""
            // Use index-based access for better performance (avoids map lookup)
            file += "    $propName = row.get($index)$decoder$comma\n"
        }

        file += ")\n"
    }

    /**
     * Generates the function for applying batch result rows to a collection of entities.
     *
     * @param file The output stream to write the generated code.
     * @param className The fully qualified class name.
     * @param returningProps The properties to include in the copy.
     * @param functionName The name of the generated function.
     * @param docDescription Description for the KDoc.
     */
    private fun emitApplyBatchResultFunction(
        file: OutputStream,
        className: String,
        returningProps: List<KSPropertyDeclaration>,
        functionName: String,
        docDescription: String
    ) {
        if (returningProps.isEmpty()) return

        file += "\n"
        file += "/**\n"
        file += " * Merges the $docDescription back into this collection of [$className] entities.\n"
        file += " *\n"
        file += " * After executing ${if (functionName.contains("Insert")) "a batch INSERT" else "a batch UPDATE"} statement, use this function to update the entities\n"
        file += " * with database-generated values (e.g., ${if (functionName.contains("Insert")) "auto-increment IDs, default timestamps" else "auto-updated timestamps, version numbers"}).\n"
        file += " *\n"
        file += " * The result rows are matched to entities by position (order is preserved).\n"
        file += " *\n"
        file += " * @param rows The result rows from the statement execution\n"
        file += " * @param converters The registry containing custom type decoders\n"
        file += " * @return A list of new instances with the generated values merged in\n"
        file += " * @throws IllegalArgumentException if the number of rows doesn't match the number of entities\n"
        file += " */\n"
        file += "fun Iterable<$className>.$functionName(rows: List<ResultSet.Row>, converters: ValueEncoderRegistry): List<$className> {\n"
        file += "    val items = this.toList()\n"
        file += $$"    require(items.size == rows.size) { \"Result rows count (${rows.size}) doesn't match entities count (${items.size})\" }\n"
        file += "    return items.zip(rows).map { (item, row) ->\n"
        file += "        item.$functionName(row, converters)\n"
        file += "    }\n"
        file += "}\n"
    }

    operator fun OutputStream.plusAssign(str: String): Unit = write(str.toByteArray())
    private fun KSPropertyDeclaration.simpleName(): String = simpleName.getShortName()
    private fun KSClassDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSAnnotation.qualifiedName(): String? = annotationType.resolve().declaration.qualifiedName?.asString()
    private fun String.toSnakeCase(): String {
        val pattern = "(?<=.)[A-Z]".toRegex()
        return replace(pattern, "_$0").lowercase()
    }

    private fun KSPropertyDeclaration.getConverterAnnotation(): KSAnnotation? =
        annotations.find { it.qualifiedName() == TypeNames.CONVERTER_ANNOTATION }

    private fun KSAnnotation.getEncoderClassDeclaration(): KSClassDeclaration? {
        val valueArg = arguments.find { it.name?.asString() == "value" } ?: return null
        val classType = valueArg.value as? KSType ?: return null
        return classType.declaration as? KSClassDeclaration
    }

    private fun KSAnnotation.getEncoderClassName(): String? {
        val classDecl = getEncoderClassDeclaration() ?: return null
        return classDecl.qualifiedName?.asString()
    }

    private fun isBuiltInType(typeQualifiedName: String): Boolean = typeQualifiedName in BUILT_IN_TYPES

    /**
     * Validates the compatibility between a property type and its associated @Converter encoder type.
     * Ensures that @Converter annotations are only applied to valid types, checks for type matching,
     * and validates that the encoder satisfies the required conditions.
     *
     * @param prop The property declaration to be validated.
     * @param converterAnnotation The @Converter annotation applied to the property.
     * @throws IllegalStateException If the validation fails due to mismatched types, invalid encoder class definition,
     *                                or unsupported property types.
     */
    private fun validateConverterTypeCompatibility(
        prop: KSPropertyDeclaration,
        converterAnnotation: KSAnnotation
    ) {
        val propType = prop.type.resolve()
        val propTypeQualifiedName = propType.declaration.qualifiedName?.asString()
            ?: error("No type name found for property ${prop.simpleName()}")

        // Check that the property is not a built-in type
        val baseTypeName = propTypeQualifiedName.removeSuffix("?")
        if (isBuiltInType(baseTypeName)) {
            error(
                "@Converter cannot be used on built-in type '$propTypeQualifiedName'. " +
                        "Property: ${prop.simpleName()} in ${prop.parentDeclaration?.simpleName?.asString()}"
            )
        }

        val encoderClassDecl = converterAnnotation.getEncoderClassDeclaration()
            ?: error("Invalid @Converter: cannot resolve encoder class for property ${prop.simpleName()}")

        // Validate that the encoder is an object (singleton), not a class
        if (encoderClassDecl.classKind != ClassKind.OBJECT) {
            error(
                "@Converter encoder '${encoderClassDecl.qualifiedName?.asString()}' must be declared as an 'object', not a 'class'. " +
                        "Property: ${prop.simpleName()} in ${prop.parentDeclaration?.simpleName?.asString()}"
            )
        }

        // Find the ValueEncoder<T> supertype to extract T
        val valueEncoderSupertype = encoderClassDecl.superTypes
            .map { it.resolve() }
            .find { superType ->
                superType.declaration.qualifiedName?.asString() == TypeNames.VALUE_ENCODER
            }

        if (valueEncoderSupertype == null) {
            error(
                "@Converter encoder '${encoderClassDecl.qualifiedName?.asString()}' must implement ValueEncoder<T>. " +
                        "Property: ${prop.simpleName()}"
            )
        }

        // Get the type argument T from ValueEncoder<T>
        val encoderTypeArg = valueEncoderSupertype.arguments.firstOrNull()?.type?.resolve()
        val encoderTypeQualifiedName = encoderTypeArg?.declaration?.qualifiedName?.asString()

        if (encoderTypeQualifiedName == null) {
            logger.warn(
                "Cannot verify type compatibility for @Converter on property ${prop.simpleName()}. " +
                        "Encoder: ${encoderClassDecl.qualifiedName?.asString()}"
            )
            return
        }

        // Compare base types (without nullability)
        val propBaseType = propTypeQualifiedName.removeSuffix("?")
        val encoderBaseType = encoderTypeQualifiedName.removeSuffix("?")

        if (propBaseType != encoderBaseType) {
            error(
                "@Converter type mismatch: Encoder '${encoderClassDecl.qualifiedName?.asString()}' " +
                        "handles type '$encoderTypeQualifiedName' but property '${prop.simpleName()}' " +
                        "has type '$propTypeQualifiedName'."
            )
        }
    }

    /**
     * Generates a bind expression for a given property declaration. If the property is annotated with
     * a `@Converter`, the method validates the compatibility between the property type and the converter's
     * encoder type. Consequently, it generates the appropriate expression by utilizing the encoder's
     * `encode` method. If no `@Converter` is present, the property's name is returned as-is.
     *
     * @param prop The property declaration for which the bind expression is generated.
     * @return A `String` representing the bind expression for the property. If the property has a
     *         compatible `@Converter`, the resulting expression applies the encoder; otherwise,
     *         it returns the property's name.
     * @throws IllegalStateException If the `@Converter` annotation is invalid or if the encoder class
     *                                is incompatible with the property type.
     */
    private fun generateBindExpression(prop: KSPropertyDeclaration, prefix: String? = null): String {
        val propName = prop.simpleName()
        val propAccess = if (prefix != null) "$prefix.$propName" else propName
        val converterAnnotation = prop.getConverterAnnotation()
        if (converterAnnotation != null) {
            validateConverterTypeCompatibility(prop, converterAnnotation)
            val encoderClassName = converterAnnotation.getEncoderClassName()
                ?: error("Cannot get encoder class name from @Converter on property $propName")
            val propType = prop.type.resolve()
            return if (propType.isMarkedNullable) {
                "$propAccess?.let { $encoderClassName.encode(it) }"
            } else {
                "$encoderClassName.encode($propAccess)"
            }
        }
        return propAccess
    }

    companion object {
        /**
         * The default filename used for storing or generating query-related output files.
         * Typically used within the code generation process to standardize the naming
         * of generated query files.
         */
        private const val OUTPUT_FILENAME_SUFFIX = "CrudQueries"

        /**
         * Key used to specify the package name for the generated output classes.
         */
        const val PACKAGE_OPTION = "output-package"

        /**
         * The option key used to specify the SQL dialect. Supported: generic (default), mysql
         */
        private const val DIALECT_OPTION = "dialect"

        private const val INSERT_PROPERTY_NAME = "insert"
        private const val UPDATE_PROPERTY_NAME = "update"
    }
}
