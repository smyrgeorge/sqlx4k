package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

class RepositoryProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val repoSymbols = resolver
            .getSymbolsWithAnnotation(REPOSITORY_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()

        if (!repoSymbols.iterator().hasNext()) return emptyList()

        val outputPackage = options[TableProcessor.PACKAGE_OPTION]
            ?: error("Missing ${TableProcessor.PACKAGE_OPTION} option")

        val outputFilename = options[FILENAME_OPTION] ?: "GeneratedRepositories"

        val file: OutputStream = codeGenerator.createNewFile(
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = outputPackage,
            fileName = outputFilename
        )

        file += "// Generated by sqlx4k-codegen (RepositoryProcessor)\n"
        file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\")\n\n"
        file += "package $outputPackage\n\n"
        file += "import io.github.smyrgeorge.sqlx4k.Statement\n"
        file += "import io.github.smyrgeorge.sqlx4k.Driver\n"

        // For each repository interface, find methods annotated with @Query
        val validatedRepos = repoSymbols.filter { it.validate() }
        validatedRepos.forEach { iface ->
            if (iface.classKind != ClassKind.INTERFACE) {
                error("@Repository is only supported on interfaces (${iface.qualifiedName?.asString()}).")
            }

            // Extract domain and mapper from @Repository annotation on the interface
            val repoAnn: KSAnnotation =
                iface.annotations.firstOrNull { it.shortName.asString() == REPOSITORY_ANNOTATION_SHORT }
                    ?: error("Missing @Repository annotation on interface ${iface.qualifiedName?.asString()}")

            val domainArg: KSValueArgument? = repoAnn.arguments.firstOrNull { it.name?.asString() == "domain" }
            val domainKSType = domainArg?.value as? KSType
                ?: error("@Repository must declare a domain class, e.g. @Repository(Foo::class, FooRowMapper::class) on ${iface.qualifiedName?.asString()}")
            val domainDecl = domainKSType.declaration as? KSClassDeclaration
                ?: error("Domain type must be a class for ${iface.qualifiedName?.asString()}")
            val hasTable = domainDecl.annotations.any { ann ->
                val qn = ann.annotationType.resolve().declaration.qualifiedName?.asString()
                qn == "io.github.smyrgeorge.sqlx4k.annotation.Table" || ann.shortName.asString() == "Table"
            }
            if (!hasTable) error("@Repository domain must be a @Table-annotated class (${domainDecl.qualifiedName?.asString()})")

            val mapperArg: KSValueArgument? = repoAnn.arguments.firstOrNull { it.name?.asString() == "mapper" }
            val mapperKSType = mapperArg?.value as? KSType
                ?: error("@Repository must declare a mapper, e.g. @Repository(Foo::class, FooRowMapper::class) on ${iface.qualifiedName?.asString()}")
            val mapperTypeName = mapperKSType.declaration.qualifiedName?.asString()
                ?: error("Unable to resolve mapper type for ${iface.qualifiedName?.asString()}")

            val fnsAll = iface.declarations.filterIsInstance<KSFunctionDeclaration>().toList()
            if (fnsAll.isEmpty()) return@forEach

            // Determine implementation class name
            val implName = iface.name() + "Impl"

            // Emit class header
            file += "\nobject $implName : ${iface.qualifiedName?.asString()} {\n"

            // Split functions into @Query-based and CRUD (insert/update/delete) without @Query
            val queryFns = fnsAll.filter { fn -> fn.annotations.any { it.name() == QUERY_ANNOTATION_NAME } }
            // CRUD functions are only supported if interface implements CrudRepository<Domain>
            val implementsCrudRepositoryInterface = iface.superTypes.any { superType ->
                val st = superType.resolve()
                val qn = st.declaration.qualifiedName?.asString()
                if (qn != "io.github.smyrgeorge.sqlx4k.CrudRepository") return@any false
                // If CrudRepository is generic, ensure it matches domain when available
                val typeArg = st.arguments.firstOrNull()?.type?.resolve()
                val domainQn = domainDecl.qualifiedName?.asString()
                if (typeArg == null) {
                    // CrudRepository without type argument is not allowed; enforce matching by failing fast
                    error("${iface.qualifiedName?.asString()} implements CrudRepository without type argument; expected CrudRepository<$domainQn>")
                }
                val crudArgQn = typeArg.declaration.qualifiedName?.asString()
                    ?: error("Unable to resolve CrudRepository type argument for ${iface.qualifiedName?.asString()}")
                if (crudArgQn != domainQn) {
                    error("CrudRepository type argument '$crudArgQn' does not match @Repository domain '$domainQn' on ${iface.qualifiedName?.asString()}")
                }
                true
            }

            // Generate @Query-based methods: select/count/execute
            queryFns.forEach { fn ->
                val ann: KSAnnotation = fn.annotations.first { it.name() == QUERY_ANNOTATION_NAME }
                val sqlArg: KSValueArgument = ann.arguments.first { it.name?.asString() == "value" }
                val sql = sqlArg.value as String

                val name = fn.simpleName.asString()
                val params = fn.parameters
                val paramSig = params.joinToString { p ->
                    val pName = p.name?.asString() ?: "p"
                    val pType = p.type.toString()
                    "$pName: $pType"
                }

                val prefix = when {
                    name.startsWith("select") -> "select"
                    name.startsWith("count") -> "count"
                    name.startsWith("execute") -> "execute"
                    else -> error("Invalid repository method name '$name'. Must start with one of: select, count, execute.")
                }

                // Validate first parameter: must be exactly `context: Driver`
                if (params.isEmpty()) {
                    error("Repository method '$name' must declare first parameter 'context: io.github.smyrgeorge.sqlx4k.Driver'")
                }
                val first = params.first()
                val firstName = first.name?.asString()
                    ?: error("Repository method '$name' first parameter must be named 'context'")
                if (firstName != "context") {
                    error("Repository method '$name' first parameter must be named 'context'")
                }
                val firstType = first.type.resolve()
                val firstQn = firstType.declaration.qualifiedName?.asString()
                    ?: error("Unable to resolve type of first parameter for method '$name'")
                if (firstQn != "io.github.smyrgeorge.sqlx4k.Driver" || firstType.isMarkedNullable) {
                    error("Repository method '$name' first parameter must be non-null io.github.smyrgeorge.sqlx4k.Driver")
                }

                // Validate return type based on prefix rules
                val returnType = fn.returnType?.resolve()
                    ?: error("Unable to resolve return type for method '$name'")
                val resultQName = returnType.declaration.qualifiedName?.asString()
                    ?: error("Unable to resolve return type declaration for method '$name'")
                if (resultQName != "kotlin.Result") {
                    error("Repository method '$name' must return kotlin.Result<...> but returns '$returnType'")
                }
                val returnTypeArg0 = returnType.arguments.firstOrNull()?.type?.resolve()
                    ?: error("Repository method '$name' must return kotlin.Result<...> with a type argument")
                when (prefix) {
                    "select" -> {
                        val innerQName = returnTypeArg0.declaration.qualifiedName?.asString()
                            ?: error("Unable to resolve inner type for method '$name'")
                        if (innerQName != "kotlin.collections.List" || returnTypeArg0.isMarkedNullable) {
                            error("Repository method '$name' with prefix 'select' must return kotlin.Result<kotlin.collections.List<*>>")
                        }
                    }

                    "count", "execute" -> {
                        val qn0 = returnTypeArg0.declaration.qualifiedName?.asString()
                            ?: error("Unable to resolve inner type for method '$name'")
                        if (qn0 != "kotlin.Long" || returnTypeArg0.isMarkedNullable) {
                            error("Repository method '$name' with prefix '$prefix' must return kotlin.Result<kotlin.Long>")
                        }
                    }
                }

                file += "    override suspend fun $name($paramSig) = run {\n"
                file += "        // language=SQL\n"
                file += "        val statement = Statement.create(\"$sql\")\n"

                val nonContextParams = params.drop(1)
                nonContextParams.forEachIndexed { index, p ->
                    val pName = p.name?.asString() ?: "p${index + 1}"
                    file += "        statement.bind($index, $pName)\n"
                }

                val contextParamName = params.firstOrNull()?.name?.asString() ?: "context"
                when (prefix) {
                    "select" -> {
                        file += "        $contextParamName.fetchAll(statement, $mapperTypeName)\n"
                    }

                    "count" -> {
                        file += "        $contextParamName.fetchAll(statement).map { rs ->\n"
                        file += "            val row = rs.firstOrNull()\n"
                        file += "                ?: return@run Result.failure(IllegalStateException(\"Count query returned no rows\"))\n"
                        file += "            row.get(0).asString().toLong()\n"
                        file += "        }\n"
                    }

                    "execute" -> {
                        file += "        $contextParamName.execute(statement)\n"
                    }

                    else -> {
                        file += "        error(\"Unsupported method prefix\")\n"
                    }
                }
                file += "    }\n"
            }

            // Generate CRUD methods: insert/update/delete only if interface implements CrudRepository<Domain>
            if (implementsCrudRepositoryInterface) {
                val domainQn = domainDecl.qualifiedName?.asString() ?: error("Cannot resolve domain type name")
                // insert
                file += "    override suspend fun insert(context: Driver, entity: $domainQn) = run {\n"
                file += "        val statement = entity.insert()\n"
                file += "        context.fetchAll(statement, $mapperTypeName).map { list ->\n"
                file += "            val one = list.firstOrNull()\n"
                file += "                ?: return@run Result.failure(IllegalStateException(\"Insert query returned no rows\"))\n"
                file += "            one\n"
                file += "        }\n"
                file += "    }\n"
                // update
                file += "    override suspend fun update(context: Driver, entity: $domainQn) = run {\n"
                file += "        val statement = entity.update()\n"
                file += "        context.fetchAll(statement, $mapperTypeName).map { list ->\n"
                file += "            val one = list.firstOrNull()\n"
                file += "                ?: return@run Result.failure(IllegalStateException(\"Update query returned no rows\"))\n"
                file += "            one\n"
                file += "        }\n"
                file += "    }\n"
                // delete
                file += "    override suspend fun delete(context: Driver, entity: $domainQn) = run {\n"
                file += "        val statement = entity.delete()\n"
                file += "        context.execute(statement).map { kotlin.Unit }\n"
                file += "    }\n"
                // save
                file += "    override suspend fun save(context: Driver, entity: $domainQn) = run {\n"
                // Find @Id property on domain
                val idProp: KSPropertyDeclaration? = domainDecl.getAllProperties().firstOrNull { p ->
                    p.annotations.any { it.shortName.asString() == "Id" || it.annotationType.resolve().declaration.qualifiedName?.asString() == "io.github.smyrgeorge.sqlx4k.annotation.Id" }
                }
                if (idProp == null) {
                    file += "        error(\"No @Id property found in ${domainDecl.qualifiedName?.asString()}\")\n"
                    file += "    }\n"
                } else {
                    val idName = idProp.simpleName.getShortName()
                    val idType = idProp.type.resolve()
                    when (val idQn = idType.declaration.qualifiedName?.asString()) {
                        "kotlin.Int", "kotlin.Long" -> {
                            // Valid id type: generate insert or update based on zero check
                            val zeroLiteral = if (idQn == "kotlin.Int") "0" else "0L"
                            file += "        if (entity.$idName == $zeroLiteral) insert(context, entity) else update(context, entity)\n"
                            file += "    }\n"
                        }

                        else -> {
                            file += "        error(\"@Id property '$idName' must be of type Int or Long in ${domainDecl.qualifiedName?.asString()}\")\n"
                            file += "    }\n"
                        }
                    }
                }
            }
            file += "}\n"
        }
        file.close()

        val unableToProcess = repoSymbols.filterNot { it.validate() }.toList()
        return unableToProcess
    }

    private fun KSAnnotation.name(): String = shortName.asString()
    private fun KSClassDeclaration.name(): String = simpleName.asString()

    operator fun OutputStream.plusAssign(str: String) {
        write(str.toByteArray())
    }

    companion object {
        /**
         * The option key used to specify the output filename for the generated SQL classes.
         */
        private const val FILENAME_OPTION = "output-filename"
        private const val QUERY_ANNOTATION_NAME = "Query"
        private const val REPOSITORY_ANNOTATION = "io.github.smyrgeorge.sqlx4k.annotation.Repository"
        private const val REPOSITORY_ANNOTATION_SHORT = "Repository"
    }
}
