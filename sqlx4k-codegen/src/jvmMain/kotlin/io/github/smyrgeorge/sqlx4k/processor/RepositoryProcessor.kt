package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import io.github.smyrgeorge.sqlx4k.Statement
import io.github.smyrgeorge.sqlx4k.processor.utils.Quadraple
import java.io.OutputStream

class RepositoryProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    /**
     * Processes repository symbols annotated with a specific annotation, validates these symbols,
     * and generates Kotlin code for their associated functionality. The generated code is written
     * to a new file using a specified file name and package.
     *
     * @param resolver The `Resolver` instance used to discover and resolve symbols annotated
     *                 with the specified repository annotation.
     * @return A list of `KSAnnotated` symbols that could not be processed due to validation errors.
     */
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val repoSymbols = resolver
            .getSymbolsWithAnnotation(TypeNames.REPOSITORY_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
        if (!repoSymbols.iterator().hasNext()) return emptyList()

        val outputPackage = options[TableProcessor.PACKAGE_OPTION]
            ?: error("Missing ${TableProcessor.PACKAGE_OPTION} option")
        logger.info("[RepositoryProcessor] Output package: $outputPackage")

        val globalCheckSqlSyntax = options[VALIDATE_SQL_SYNTAX_OPTION]?.toBoolean() ?: true
        logger.info("[RepositoryProcessor] Validate SQL syntax: $globalCheckSqlSyntax")

        val globalCheckSqlSchema = options[VALIDATE_SQL_SCHEMA_OPTION]?.toBoolean() ?: false
        logger.info("[RepositoryProcessor] Validate SQL schema: $globalCheckSqlSchema")
        val schemaMigrationsPath = options[SCHEMA_MIGRATIONS_PATH_OPTION] ?: "./set-the-path-to-schema-migrations"

        // Load schemas.
        if (globalCheckSqlSchema) SqlValidator.loadSchema(schemaMigrationsPath)

        // For each repository interface, find methods annotated with @Query
        val validatedRepos = repoSymbols.filter { it.validate() }
        validatedRepos.forEach { repo ->
            if (repo.classKind != ClassKind.INTERFACE)
                error("@Repository is only supported on interfaces (${repo.qualifiedName()}).")

            // Extract domain and mapper from @Repository annotation on the interface.
            val (domainDecl, mapperTypeName, useContextParameters, useArrow) = parseRepositoryAnnotation(repo)

            // Calculate imports.
            val imports = setOfNotNull(
                TypeNames.STATEMENT,
                TypeNames.QUERY_EXECUTOR,
                TypeNames.SQL_ERROR,
                if (useArrow) TypeNames.TO_DB_RESULT else null
            )

            // Parse hooks.
            val (hooks, hookImports) = parsQueryeHooks(repo, domainDecl)

            // Determine implementation class name
            val implName = "${repo.simpleName()}Impl"
            logger.info("[RepositoryProcessor] Generating implementation object $implName for ${repo.qualifiedName()}")

            val file: OutputStream = codeGenerator.createNewFile(
                // Make sure to associate the generated file with sources to keep/maintain it across incremental builds.
                // Learn more about incremental processing in KSP from the official docs:
                // https://kotlinlang.org/docs/ksp-incremental.html
                dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
                packageName = outputPackage,
                fileName = "$implName.kt"
            )

            // Render file header.
            file += "// Generated by sqlx4k-codegen (RepositoryProcessor)\n"
            @Suppress("DuplicatedCode")
            file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\", \"SqlDialectInspection\", \"UnnecessaryVariable\")\n\n"
            file += "package $outputPackage\n\n"
            (imports + hookImports).sorted().forEach { file += "import $it\n" }

            // Find all methods declared in the interface
            val fnsAll = repo.declarations.filterIsInstance<KSFunctionDeclaration>().toList()

            // Emit class header
            file += "\nobject $implName : ${repo.qualifiedName()} {\n"

            // Generate @Query-based methods according to prefixes:
            // findAll/findAllBy/findOneBy/deleteBy/countBy/execute and also *All variants
            fnsAll
                .filter { fn -> fn.annotations.any { it.qualifiedName() == TypeNames.QUERY_ANNOTATION } }
                .forEach { fn ->
                    val queryAnn = fn.annotations.first { it.qualifiedName() == TypeNames.QUERY_ANNOTATION }
                    val localCheckSyntax = queryAnn.arguments
                        .firstOrNull { it.name?.asString() == "checkSyntax" }
                        ?.value as? Boolean ?: true
                    val localCheckSchema = queryAnn.arguments
                        .firstOrNull { it.name?.asString() == "checkSchema" }
                        ?.value as? Boolean ?: true
                    val doCheckSyntax = globalCheckSqlSyntax && localCheckSyntax
                    val doCheckSchema = globalCheckSqlSchema && localCheckSchema
                    emitQueryMethod(
                        file = file,
                        fn = fn,
                        validateSyntax = doCheckSyntax,
                        validateSchema = doCheckSchema,
                        mapperTypeName = mapperTypeName,
                        domainDecl = domainDecl,
                        useArrow = useArrow
                    )
                }

            // Generate CRUD methods: insert/update/delete;
            // Interface must implement CrudRepository<Domain> which we already validated.
            emitCrudMethods(
                file = file,
                domainDecl = domainDecl,
                mapperTypeName = mapperTypeName,
                hooks = hooks,
                useContextParameters = useContextParameters,
                useArrow = useArrow
            )
            file += "}\n"
            file.close()
        }

        val unableToProcess = repoSymbols.filterNot { it.validate() }.toList()
        return unableToProcess
    }

    /**
     * Represents the valid prefixes for repository method names in the `RepositoryProcessor` class.
     *
     * These prefixes define the type of operation that a repository method performs, such as finding,
     * deleting, counting, or executing operations on a domain model. The primary usage of this enum
     * is to map method names to their corresponding behavior and ensure methods adhere to the expected
     * naming conventions in the repository interface.
     *
     * The valid prefixes are:
     * - `FIND_ALL`: Indicates methods that fetch all instances of a domain model.
     * - `DELETE_ALL`: Indicates methods that delete all instances of a domain model.
     * - `COUNT_ALL`: Indicates methods that count all instances of a domain model.
     * - `FIND_ALL_BY`: Indicates methods that fetch multiple instances of a domain model based on certain conditions.
     * - `FIND_ONE_BY`: Indicates methods that fetch a single instance of a domain model based on certain conditions.
     * - `DELETE_BY`: Indicates methods that delete instances of a domain model based on certain conditions.
     * - `COUNT_BY`: Indicates methods that count instances of a domain model based on certain conditions.
     * - `EXECUTE`: Indicates methods that perform a custom execution, typically associated with annotated SQL queries.
     *
     * This enum is used internally by the `RepositoryProcessor` to parse method names, validate method
     * signatures, and generate the appropriate method implementations for repository interfaces.
     */
    private enum class Prefix {
        FIND_ONE_BY,
        FIND_ALL_BY,
        FIND_ALL,
        DELETE_BY,
        DELETE_ALL,
        COUNT_BY,
        COUNT_ALL,
        EXECUTE
    }

    /**
     * Parses the method name to determine its prefix and maps it to the corresponding `Prefix` enumeration value.
     * The method identifies valid repository method prefixes such as `findAll`, `deleteAll`, `countAll`, and more,
     * as well as prefixes that start with specific patterns like `findAllBy`, `findOneBy`, etc.
     * If the method name doesn't match any valid prefix, an error is thrown.
     *
     * @param name The name of the repository method that needs to be parsed.
     * @return The detected `Prefix` value corresponding to the method prefix.
     * @throws IllegalStateException if the method name does not correspond to a valid repository method prefix.
     */
    private fun parseMethodPrefix(name: String): Prefix = when {
        name == "findAll" -> Prefix.FIND_ALL
        name == "deleteAll" -> Prefix.DELETE_ALL
        name == "countAll" -> Prefix.COUNT_ALL
        name.startsWith("findAllBy") -> Prefix.FIND_ALL_BY
        name.startsWith("findOneBy") -> Prefix.FIND_ONE_BY
        name.startsWith("deleteBy") -> Prefix.DELETE_BY
        name.startsWith("countBy") -> Prefix.COUNT_BY
        name.startsWith("execute") -> Prefix.EXECUTE
        else -> error("Invalid repository method name '$name'. Must be one of: findAll, deleteAll, countAll or start with: findAllBy, findOneBy, deleteBy, countBy, execute.")
    }

    /**
     * Parses the `@Repository` annotation on a given repository interface and validates its structure.
     * Ensures the repository interface properly extends a supported `CrudRepository` variant and retrieves
     * necessary metadata such as the domain type, the mapper type, and whether Arrow support is used.
     *
     * @param repo The repository interface declaration to analyze.
     * @return A Triple containing:
     *         - The class declaration of the domain type used by the repository.
     *         - The fully qualified name of the mapper type specified in the repository annotation.
     *         - A Boolean flag indicating whether context-specific repository parameters are enabled.
     *         - A Boolean flag indicating whether Arrow-specific repository support is enabled.
     */
    private fun parseRepositoryAnnotation(repo: KSClassDeclaration): Quadraple<KSClassDeclaration, String, Boolean, Boolean> {
        // Recursively find a supertype that matches one of the repository types
        fun findCrudRepositorySuperType(
            decl: KSClassDeclaration,
            visited: MutableSet<String> = mutableSetOf()
        ): KSType? {
            val qualifiedName = decl.qualifiedName() ?: return null

            // Avoid infinite recursion
            if (qualifiedName in visited) return null
            visited.add(qualifiedName)

            // Check direct supertypes
            for (superType in decl.superTypes) {
                val resolved = superType.resolve()
                val superQualifiedName = resolved.declaration.qualifiedName()
                if (superQualifiedName in TypeNames.REPOSITORY_TYPE_NAMES) {
                    return resolved
                }
            }

            // Recursively check supertypes of supertypes
            for (superType in decl.superTypes) {
                val resolved = superType.resolve()
                val superDecl = resolved.declaration as? KSClassDeclaration ?: continue
                val found = findCrudRepositorySuperType(superDecl, visited)
                if (found != null) return found
            }

            return null
        }

        fun implementsCrudRepository(repo: KSClassDeclaration): Triple<KSClassDeclaration, Boolean, Boolean> {
            val repoTypeNames = TypeNames.REPOSITORY_TYPE_NAMES

            // Extract repository super-type information
            if (repo.superTypes.toList().size > 1) error("Repository interface ${repo.qualifiedName()} cannot extend multiple repositories")

            // Validate that somewhere in the hierarchy we extend one of the allowed repository types
            val foundRepoType = findCrudRepositorySuperType(repo)
                ?: error("@Repository interface ${repo.qualifiedName()} must extend (directly or indirectly) one of ${repoTypeNames.joinToString { "$it<T>" }}")

            // Extract repository type information from the found repository type
            val useContextParameters =
                foundRepoType.declaration.qualifiedName() in TypeNames.CONTEXT_REPOSITORY_TYPE_NAMES
            val useArrow = foundRepoType.declaration.qualifiedName() in TypeNames.ARROW_REPOSITORY_TYPE_NAMES

            // Extract domain type information from the DIRECT supertype (first level)
            val directSuperType = repo.superTypes.firstOrNull()?.resolve()
                ?: error("Repository interface ${repo.qualifiedName()} has no supertypes")
            val typeArg = directSuperType.arguments.firstOrNull()?.type?.resolve()
                ?: error("${repo.qualifiedName()} implements ${directSuperType.declaration.qualifiedName()} without type argument; expected it to have a type argument <T>")
            val domainDecl = typeArg.declaration as? KSClassDeclaration
                ?: error("Type argument must be a class on ${repo.qualifiedName()}")

            // Ensure @Table
            val hasTable = domainDecl.annotations.any {
                val qn = it.qualifiedName()
                qn == TypeNames.TABLE_ANNOTATION
            }
            if (!hasTable) error("Repository generic parameter must be @Table-annotated (${domainDecl.qualifiedName()})")
            return Triple(domainDecl, useContextParameters, useArrow)
        }

        val repoAnn = repo.annotations.firstOrNull { it.qualifiedName() == TypeNames.REPOSITORY_ANNOTATION }
            ?: error("Missing @Repository annotation on interface ${repo.qualifiedName()}")

        // Enforce that the interface extends CrudRepository<T> and derive domain from T
        val (domainDecl, useContextParameters, useArrow) = implementsCrudRepository(repo)

        val mapperArg: KSValueArgument? = repoAnn.arguments.firstOrNull { it.name?.asString() == "mapper" }
        val mapperKSType = mapperArg?.value as? KSType
            ?: error("@Repository must declare a mapper, e.g. @Repository(mapper = FooRowMapper::class) on ${repo.qualifiedName()}")
        val mapperTypeName = mapperKSType.declaration.qualifiedName()
            ?: error("Unable to resolve mapper type for ${repo.qualifiedName()}")
        return Quadraple(domainDecl, mapperTypeName, useContextParameters, useArrow)
    }

    /**
     * Parses all methods in the repository that are annotated with @Query.Hook.
     *
     * @param repo The repository interface declaration to analyze.
     * @param domainDecl The class declaration of the repository's domain type.
     * @return A Pair containing:
     *         - A list of HookInfo objects representing parsed hook annotations
     *         - A set of import statements needed for the hook context parameters
     */
    private fun parsQueryeHooks(
        repo: KSClassDeclaration,
        domainDecl: KSClassDeclaration
    ): Pair<List<HookInfo>, Set<String>> {
        val hooks = mutableListOf<HookInfo>()
        val imports = mutableSetOf<String>()

        // Recursively collect hooks from this interface and all parent interfaces
        fun collectHooksRecursively(decl: KSClassDeclaration, visited: MutableSet<String> = mutableSetOf()) {
            val qualifiedName = decl.qualifiedName() ?: return

            // Avoid infinite recursion
            if (qualifiedName in visited) return
            visited.add(qualifiedName)

            // Process hooks in current interface
            decl.declarations.filterIsInstance<KSFunctionDeclaration>().forEach { fn ->
                val hookAnn = fn.annotations
                    .firstOrNull { it.qualifiedName() == TypeNames.QUERY_HOOK_ANNOTATION }
                    ?: return@forEach

                logger.info("[RepositoryProcessor] Found hook annotation on method: ${fn.simpleName()} in ${decl.qualifiedName()}")

                // Parse kind
                val kindArg = hookAnn.arguments.firstOrNull { it.name?.asString() == "kind" }
                val kindValue = kindArg?.value?.toString()?.removePrefix("Kind.")
                    ?: error("Hook annotation must have a kind")
                val kind = HookInfo.Kind.valueOf(kindValue)

                val callFromDefaultCrudMethodsArg =
                    hookAnn.arguments.firstOrNull { it.name?.asString() == "callFromDefaultCrudMethod" }
                val callFromDefaultCrudMethod =
                    callFromDefaultCrudMethodsArg?.value?.toString()?.toBooleanStrictOrNull() ?: true

                // Validate that the hook method has a body
                if (fn.isAbstract) {
                    error("Hook method '${fn.simpleName()}' in ${decl.qualifiedName()} must have a body (cannot be abstract)")
                }

                // Validate PRE_INSERT, PRE_UPDATE, PRE_DELETE hooks
                when (kind) {
                    HookInfo.Kind.PRE_INSERT, HookInfo.Kind.PRE_UPDATE, HookInfo.Kind.PRE_DELETE -> {
                        val methodName = fn.simpleName()
                        val params = fn.parameters

                        // Validate exactly one parameter
                        if (params.size != 1) {
                            error("Hook method '$methodName' with kind $kind must have exactly one parameter of type ${domainDecl.qualifiedName()}, but has ${params.size} parameters")
                        }

                        // Validate parameter type matches domain type (or is a type parameter)
                        val param = params.first()
                        val paramType = param.type.resolve()
                        val domainQn = domainDecl.qualifiedName()

                        // Accept type parameters (for hooks defined in generic parent interfaces)
                        val isTypeParameter = paramType.declaration is KSTypeParameter
                        if (!isTypeParameter) {
                            val paramQn = paramType.declaration.qualifiedName?.asString()
                            if (paramQn != domainQn || paramType.isMarkedNullable) {
                                error("Hook method '$methodName' with kind $kind must have a parameter of type $domainQn (non-nullable), but has type $paramType")
                            }
                        } else if (paramType.isMarkedNullable) {
                            error("Hook method '$methodName' with kind $kind must have a non-nullable parameter, but has type $paramType")
                        }

                        // Validate return type matches domain type (or is a type parameter)
                        val returnType = fn.returnType?.resolve()
                            ?: error("Unable to resolve return type for hook method '$methodName'")
                        val isReturnTypeParameter = returnType.declaration is KSTypeParameter
                        if (!isReturnTypeParameter) {
                            val returnQn = returnType.declaration.qualifiedName?.asString()
                            if (returnQn != domainQn || returnType.isMarkedNullable) {
                                error("Hook method '$methodName' with kind $kind must return type $domainQn (non-nullable), but returns $returnType")
                            }
                        } else if (returnType.isMarkedNullable) {
                            error("Hook method '$methodName' with kind $kind must return a non-nullable type, but returns $returnType")
                        }
                    }

                    HookInfo.Kind.QUERY -> {
                        // No specific validation for QUERY hooks yet
                    }
                }

                hooks.add(HookInfo(fn, kind, callFromDefaultCrudMethod))
            }

            // Recursively process parent interfaces
            for (superType in decl.superTypes) {
                val resolved = superType.resolve()
                val superDecl = resolved.declaration as? KSClassDeclaration ?: continue
                collectHooksRecursively(superDecl, visited)
            }
        }

        // Start recursive collection from the repository interface
        collectHooksRecursively(repo)

        // Ensure no multiple hooks of the same kind.
        val kindGroups = hooks.groupBy { it.kind }
        kindGroups.forEach { (kind, hookList) ->
            if (hookList.size > 1) {
                val functionNames = hookList.joinToString(", ") { it.function.simpleName() }
                error("Repository ${repo.qualifiedName()} has multiple hooks of kind $kind: $functionNames")
            }
        }

        logger.info("[RepositoryProcessor] Found ${hooks.size} hook(s) in ${repo.qualifiedName()}")
        return Pair(hooks, imports)
    }

    /**
     * Validates the context parameter for a given function declaration and detects whether
     * the method uses context parameters.
     *
     * @param fn The function declaration to validate.
     * @return Boolean indicating whether the method uses context parameters.
     */
    private fun validateContextParameter(
        fn: KSFunctionDeclaration
    ): Boolean {
        val name = fn.simpleName()
        val params = fn.parameters

        // TODO: when KSP adds support context parameters, we will have to revise this logic.
        // Detect if using context parameters by checking if first param is 'context: QueryExecutor'
        val firstParam = params.firstOrNull()
        val usesContextParameters = if (firstParam != null) {
            val firstType = firstParam.type.resolve()
            val firstQn = firstType.declaration.qualifiedName()
            val firstName = firstParam.name?.asString()
            // If first param is NOT 'context: QueryExecutor', then using context parameters
            !(firstName == "context" && firstQn == TypeNames.QUERY_EXECUTOR && !firstType.isMarkedNullable)
        } else {
            // No parameters at all, must be using context parameters
            true
        }

        if (usesContextParameters) {
            // Using context parameters: ensure there is no explicit parameter of type QueryExecutor
            val hasExplicitContextParam = params.any { p ->
                val pType = p.type.resolve()
                val qn = pType.declaration.qualifiedName()
                qn == TypeNames.QUERY_EXECUTOR
            }
            if (hasExplicitContextParam) {
                error("Repository method '$name' must not declare parameter '${TypeNames.QUERY_EXECUTOR}' when using context parameters")
            }
        } else {
            // Not using context parameters: the first parameter must be 'context: QueryExecutor'
            if (params.isEmpty())
                error("Repository method '$name' must declare first parameter 'context: ${TypeNames.QUERY_EXECUTOR}'")
            val first = params.first()
            val firstName = first.name?.asString()
                ?: error("Repository method '$name' first parameter must be named 'context'")
            if (firstName != "context")
                error("Repository method '$name' first parameter must be named 'context'")
            val firstType = first.type.resolve()
            val firstQn = firstType.declaration.qualifiedName()
                ?: error("Unable to resolve type of first parameter for method '$name'")
            if (firstQn != TypeNames.QUERY_EXECUTOR || firstType.isMarkedNullable)
                error("Repository method '$name' first parameter must be non-null ${TypeNames.QUERY_EXECUTOR}")
        }

        return usesContextParameters
    }

    /**
     * Validates the return type of a repository method based on its prefix and domain type.
     *
     * @param prefix The prefix of the method, used to determine its behavior and expected return type.
     * @param fn The function declaration representing the repository method to validate.
     * @param domainDecl The class declaration of the repository's domain type.
     * @param useArrow Whether to use context parameters for the method.
     */
    private fun validateReturnType(
        prefix: Prefix,
        fn: KSFunctionDeclaration,
        domainDecl: KSClassDeclaration,
        useArrow: Boolean
    ) {
        val name = fn.simpleName()
        val returnType = fn.returnType?.resolve()
            ?: error("Unable to resolve return type for method '$name'")
        val resultQName = returnType.declaration.qualifiedName()
            ?: error("Unable to resolve return type declaration for method '$name'")

        // Check the return type.
        if (useArrow) {
            if (resultQName != TypeNames.DB_RESULT)
                error("Repository method '$name' must return ${TypeNames.DB_RESULT}<...> when using context parameters but returns '$returnType'")
        } else {
            if (resultQName != TypeNames.KOTLIN_RESULT)
                error("Repository method '$name' must return kotlin.Result<...> but returns '$returnType'")
        }

        val r0 = returnType.arguments.firstOrNull()?.type?.resolve()
            ?: error("Repository method '$name' must return kotlin.Result<...> with a type argument")

        fun ensureDomain(inner: KSType, allowNullable: Boolean) {
            val innerDecl = inner.declaration as? KSClassDeclaration
                ?: error("Unable to resolve inner domain type for method '$name'")
            val innerQn = innerDecl.qualifiedName()
                ?: error("Unable to resolve inner domain type name for method '$name'")
            val domainQn = domainDecl.qualifiedName()
                ?: error("Unable to resolve repository domain type name")
            if (innerQn != domainQn)
                error("Method '$name' must use repository domain type '$domainQn' but found '$innerQn'")
            if (!allowNullable && inner.isMarkedNullable)
                error("Method '$name' domain return type must be non-nullable")
        }

        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> {
                val listQn = r0.declaration.qualifiedName()
                    ?: error("Unable to resolve inner type for method '$name'")
                if (listQn != TypeNames.KOTLIN_LIST || r0.isMarkedNullable)
                    error("Method '$name' must return Result<List<T>> where T is the repository domain type")
                val tArg = r0.arguments.firstOrNull()?.type?.resolve()
                    ?: error("Method '$name' must return Result<List<T>> with a generic argument")
                ensureDomain(tArg, allowNullable = false)
            }

            Prefix.FIND_ONE_BY -> {
                ensureDomain(r0.makeNotNullable(), allowNullable = true)
                if (!r0.isMarkedNullable)
                    error("Method '$name' must return Result<T?> where T is the repository domain type")
            }

            Prefix.DELETE_ALL, Prefix.COUNT_ALL, Prefix.DELETE_BY, Prefix.COUNT_BY, Prefix.EXECUTE -> {
                val qn0 = r0.declaration.qualifiedName()
                    ?: error("Unable to resolve inner type for method '$name'")
                if (qn0 != TypeNames.KOTLIN_LONG || r0.isMarkedNullable)
                    error("Method '$name' with prefix '${prefix.name.lowercase()}' must return kotlin.Result<kotlin.Long>")
            }
        }
    }

    /**
     * Validates the arity of the parameters in a repository method based on its prefix and other constraints.
     *
     * @param prefix The prefix of the method, which determines the expected parameter count and validation rules.
     * @param fn The function declaration to validate.
     * @param useContextParameters A flag indicating whether the method uses context parameters.
     *      If true, context parameters are excluded from standard parameter arity validation.
     */
    private fun validateParameterArity(
        prefix: Prefix,
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val params = fn.parameters
        val nonContextCount = if (useContextParameters) params.size else params.size - 1
        when (prefix) {
            Prefix.FIND_ALL, Prefix.DELETE_ALL, Prefix.COUNT_ALL -> if (nonContextCount != 0) error("Method '$name' must not have parameters other than context")
            Prefix.FIND_ALL_BY, Prefix.FIND_ONE_BY, Prefix.DELETE_BY, Prefix.COUNT_BY -> if (nonContextCount < 1) error(
                "Method '$name' must have more than one argument (at least one after context)"
            )

            Prefix.EXECUTE -> {}
        }
    }

    /**
     * Validates the parameters in a repository method in the context of a SQL query.
     *
     * This method checks the compatibility between the parameters declared in a repository method
     * and the named parameters used in the associated SQL query.
     *
     * @param sql The SQL query string associated with the repository method.
     * @param fn The repository method declaration (`KSFunctionDeclaration`) containing parameters to be validated.
     * @param useContextParameters A flag indicating whether the method uses context parameters. If `true`,
     *                              the first parameter (assumed to be the context parameter) is excluded from validation.
     * @throws IllegalStateException If:
     * - Positional parameters are used in the SQL query.
     * - The number of method parameters does not match the number of named parameters in the SQL query.
     * - Any method parameter is missing a corresponding named parameter in the SQL query.
     * - Any method parameter lacks a name.
     */
    fun validateParameters(
        sql: String,
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val statement = Statement.create(sql)
        if (statement.extractedPositionalParameters > 0)
            error("Method '$name' uses positional parameters in @Query (only named parameters are supported).")
        // Exclude 'context' argument.
        val parameters = if (useContextParameters) fn.parameters else fn.parameters.drop(1)
        if (parameters.size != statement.extractedNamedParameters.size)
            error("Method '$name' has ${parameters.size} parameters but @Query statement has ${statement.extractedNamedParameters.size} named parameters.")
        parameters.forEach { p ->
            val pName = p.name?.asString()
                ?: error("All query parameters must be named when using namedParameters support")
            if (!statement.extractedNamedParameters.contains(pName))
                error("Method '$name' has parameter '$pName' but @Query statement does not contain a named parameter with that name.")
        }
    }

    /**
     * Emits named parameter bindings for a given list of parameters into the specified output stream.
     * This method assumes that parameters after the first one must be named and generates binding statements accordingly.
     *
     * @param file The OutputStream where the named parameter-binding statements will be written.
     * @param params A list of KSValueParameter objects representing the parameters for which bindings are generated. The first parameter is excluded from processing.
     */
    private fun emitNamedParameterBindings(
        file: OutputStream,
        params: List<KSValueParameter>
    ) {
        params.drop(1).forEach { p ->
            val pName = p.name?.asString()
                ?: error("All query parameters must be named when using namedParameters support")
            file += "        statement.bind(\"$pName\", $pName)\n"
        }
    }

    /**
     * Generates the implementation of a repository method annotated with `@Query`.
     *
     * @param file The output stream where the generated method will be written.
     * @param fn The function declaration representing the annotated method.
     * @param validateSyntax A flag indicating whether the SQL syntax should be validated.
     * @param validateSchema A flag indicating whether the SQL query should be validated against the schema.
     * @param mapperTypeName The name of the mapper used for mapping query results.
     * @param domainDecl The class declaration representing the domain entity associated with this repository.
     * @param useArrow A flag indicating whether the generated method uses the Arrow library.
     */
    private fun emitQueryMethod(
        file: OutputStream,
        fn: KSFunctionDeclaration,
        validateSyntax: Boolean,
        validateSchema: Boolean,
        mapperTypeName: String,
        domainDecl: KSClassDeclaration,
        useArrow: Boolean
    ) {
        val name = fn.simpleName()
        val prefix: Prefix = parseMethodPrefix(name)
        logger.info("[RepositoryProcessor] Generating @Query method: $name")

        val sql: String = fn.annotations.first { it.qualifiedName() == TypeNames.QUERY_ANNOTATION }
            .arguments.firstOrNull { it.name?.asString() == "value" }
            ?.value as? String
            ?: error("Unable to generate query method (could not extract sql query from the @Query): $fn")

        val params = fn.parameters
        val paramSig = params.joinToString { p ->
            val pName = p.name?.asString() ?: "p"
            val pType = p.type.toString()
            "$pName: $pType"
        }

        val methodUsesContextParameters = validateContextParameter(fn)
        validateParameterArity(prefix, fn, methodUsesContextParameters)
        validateParameters(sql, fn, methodUsesContextParameters)
        validateReturnType(prefix, fn, domainDecl, useArrow)
        if (validateSyntax) SqlValidator.validateQuerySyntax(fn.simpleName(), sql)
        if (validateSchema) SqlValidator.validateQuerySchema(fn.simpleName(), sql)

        logger.info("[RepositoryProcessor] Emitting method '$name' with prefix ${prefix.name} in ${domainDecl.qualifiedName()} using mapper $mapperTypeName")

        // Generate KDoc
        file += "    /**\n"
        file += "     * Generated implementation of [$name]\n"
        file += "     *\n"
        file += "     * SQL: `$sql`\n"
        file += "     *\n"
        if (!methodUsesContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        params.drop(if (methodUsesContextParameters) 0 else 1).forEach { p ->
            val pName = p.name?.asString() ?: "param"
            file += "     * @param $pName Query parameter\n"
        }
        val returnDesc = when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> "Result containing list of ${domainDecl.simpleName()} entities"
            Prefix.FIND_ONE_BY -> "Result containing a single ${domainDecl.simpleName()} entity or null if not found"
            Prefix.DELETE_ALL, Prefix.DELETE_BY, Prefix.EXECUTE -> "Result containing the number of affected rows"
            Prefix.COUNT_ALL, Prefix.COUNT_BY -> "Result containing the count"
        }
        file += "     * @return $returnDesc, or an error if the operation fails\n"
        file += "     */\n"

        if (methodUsesContextParameters) {
            file += "    context(context: QueryExecutor)\n"
        }
        file += "    override suspend fun $name($paramSig) = run {\n"
        file += "        // language=SQL\n"
        file += "        val statement = Statement.create(\"$sql\")\n"
        emitNamedParameterBindings(file, params)

        val contextParamName =
            if (methodUsesContextParameters) "context"
            else params.firstOrNull()?.name?.asString() ?: "context"

        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> {
                file += "        $contextParamName.fetchAll(statement, $mapperTypeName)\n"
            }

            Prefix.FIND_ONE_BY -> {
                file += "        $contextParamName.fetchAll(statement, $mapperTypeName).map { list ->\n"
                file += "            when (list.size) {\n"
                file += "                0 -> null\n"
                file += "                1 -> list.first()\n"
                file += "                else -> return@run Result.failure(SQLError(SQLError.Code.MultipleRowsReturned, \"findOneBy query returned more than one row\"))\n"
                file += "            }\n"
                file += "        }\n"
            }

            Prefix.DELETE_ALL, Prefix.DELETE_BY, Prefix.EXECUTE -> {
                file += "        $contextParamName.execute(statement)\n"
            }

            Prefix.COUNT_ALL, Prefix.COUNT_BY -> {
                file += "        $contextParamName.fetchAll(statement).map { rs ->\n"
                file += "            val row = rs.firstOrNull()\n"
                file += "                ?: return@run Result.failure(SQLError(SQLError.Code.EmpryResultSet, \"Count query returned no rows\"))\n"
                file += "            row.get(0).asString().toLong()\n"
                file += "        }\n"
            }
        }
        file += "    }"
        if (useArrow) file += ".toDbResult()"
        file += "\n\n"
    }

    /**
     * Generates CRUD methods (insert, update, delete, save) for the provided domain class and writes
     * the method definitions to the specified output stream.
     *
     * @param file the output stream where the generated CRUD methods will be written
     * @param domainDecl the class declaration of the domain object for which CRUD methods are generated
     * @param mapperTypeName the name of the mapper type used to map query results to the domain object
     * @param hooks list of hook information for the repository
     * @param useContextParameters whether to include `QueryExecutor` as a context parameter in the method signatures
     * @param useArrow whether to use the Arrow library for error handling in the generated methods
     */
    private fun emitCrudMethods(
        file: OutputStream,
        domainDecl: KSClassDeclaration,
        mapperTypeName: String,
        hooks: List<HookInfo>,
        useContextParameters: Boolean,
        useArrow: Boolean
    ) {
        val domainQn = domainDecl.qualifiedName() ?: error("Cannot resolve domain type name")
        val domainSimpleName = domainDecl.simpleName()
        logger.info("[RepositoryProcessor] Generating CRUD methods for $domainQn")

        // insert
        logger.info("[RepositoryProcessor] Emitting CRUD method: insert($domainQn)")
        file += "    /**\n"
        file += "     * Inserts a new $domainSimpleName entity into the database.\n"
        file += "     *\n"
        file += "     * Executes an INSERT statement and returns the inserted entity with any\n"
        file += "     * generated values (e.g., auto-incremented IDs) populated.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to insert\n"
        file += "     * @return Result containing the inserted $domainSimpleName with generated values,\n"
        file += "     *         or an error if the insert operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun insert(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun insert(context: QueryExecutor, entity: $domainQn) = run {\n"
        }

        val preInsertHook = hooks.firstOrNull { it.kind == HookInfo.Kind.PRE_INSERT }
        file += if (preInsertHook != null && preInsertHook.callFromDefaultCrudMethod) {
            "        val e = ${preInsertHook.function.simpleName()}(entity)\n"
        } else {
            "        val e = entity\n"
        }

        file += "        val statement = e.insert()\n"
        file += "        context.fetchAll(statement, $mapperTypeName).map { list ->\n"
        file += "            val one = list.firstOrNull()\n"
        file += "                ?: return@run Result.failure(SQLError(SQLError.Code.EmpryResultSet, \"Insert query returned no rows\"))\n"
        file += "            one\n"
        file += "        }\n"
        file += "    }"
        if (useArrow) file += ".toDbResult()"
        file += "\n\n"

        // update
        logger.info("[RepositoryProcessor] Emitting CRUD method: update($domainQn)")
        file += "    /**\n"
        file += "     * Updates an existing $domainSimpleName entity in the database.\n"
        file += "     *\n"
        file += "     * Executes an UPDATE statement based on the entity's ID and returns\n"
        file += "     * the updated entity with any modified values.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to update\n"
        file += "     * @return Result containing the updated $domainSimpleName entity,\n"
        file += "     *         or an error if the update operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun update(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun update(context: QueryExecutor, entity: $domainQn) = run {\n"
        }

        val preUpdateHook = hooks.firstOrNull { it.kind == HookInfo.Kind.PRE_UPDATE }
        file += if (preUpdateHook != null && preUpdateHook.callFromDefaultCrudMethod) {
            "        val e = ${preUpdateHook.function.simpleName()}(entity)\n"
        } else {
            "        val e = entity\n"
        }

        file += "        val statement = e.update()\n"
        file += "        context.fetchAll(statement, $mapperTypeName).map { list ->\n"
        file += "            val one = list.firstOrNull()\n"
        file += "                ?: return@run Result.failure(SQLError(SQLError.Code.EmpryResultSet, \"Update query returned no rows\"))\n"
        file += "            one\n"
        file += "        }\n"
        file += "    }"
        if (useArrow) file += ".toDbResult()"
        file += "\n\n"

        // delete
        logger.info("[RepositoryProcessor] Emitting CRUD method: delete($domainQn)")
        file += "    /**\n"
        file += "     * Deletes a $domainSimpleName entity from the database.\n"
        file += "     *\n"
        file += "     * Executes a DELETE statement based on the entity's ID.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to delete\n"
        file += "     * @return Result containing Unit on success,\n"
        file += "     *         or an error if the delete operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun delete(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun delete(context: QueryExecutor, entity: $domainQn) = run {\n"
        }

        val preDeleteHook = hooks.firstOrNull { it.kind == HookInfo.Kind.PRE_DELETE }
        file += if (preDeleteHook != null && preDeleteHook.callFromDefaultCrudMethod) {
            "        val e = ${preDeleteHook.function.simpleName()}(entity)\n"
        } else {
            "        val e = entity\n"
        }

        file += "        val statement = e.delete()\n"
        file += "        context.execute(statement).map { kotlin.Unit }\n"
        file += "    }"
        if (useArrow) file += ".toDbResult()"
        file += "\n\n"

        // save
        logger.info("[RepositoryProcessor] Emitting CRUD method: save($domainQn)")
        file += "    /**\n"
        file += "     * Saves a $domainSimpleName entity to the database.\n"
        file += "     *\n"
        file += "     * Automatically determines whether to INSERT (if entity is new) or\n"
        file += "     * UPDATE (if entity already exists) based on the ID field value.\n"
        file += "     * For Int IDs, 0 indicates a new entity. For Long IDs, 0L indicates new.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to save\n"
        file += "     * @return Result containing the saved $domainSimpleName entity,\n"
        file += "     *         or an error if the save operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun save(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun save(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        val idProp: KSPropertyDeclaration? = domainDecl.getAllProperties().firstOrNull { p ->
            p.annotations.any { it.qualifiedName() == TypeNames.ID_ANNOTATION }
        }
        if (idProp == null) {
            file += "        error(\"No @Id property found in ${domainDecl.qualifiedName()}\")\n"
            file += "    }\n"
        } else {
            val idName = idProp.simpleName.getShortName()
            when (val idQn = idProp.type.resolve().declaration.qualifiedName()) {
                TypeNames.KOTLIN_INT, TypeNames.KOTLIN_LONG -> {
                    val zeroLiteral = if (idQn == TypeNames.KOTLIN_INT) "0" else "0L"
                    file += if (useContextParameters) {
                        "        if (entity.$idName == $zeroLiteral) insert(entity) else update(entity)\n"
                    } else {
                        "        if (entity.$idName == $zeroLiteral) insert(context, entity) else update(context, entity)\n"
                    }
                    file += "    }\n"
                }

                else -> {
                    file += "        error(\"@Id property '$idName' must be of type Int or Long in ${domainDecl.qualifiedName()}\")\n"
                    file += "    }\n"
                }
            }
        }
    }

    operator fun OutputStream.plusAssign(str: String): Unit = write(str.toByteArray())
    private fun KSDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSClassDeclaration.simpleName(): String = simpleName.asString()
    private fun KSFunctionDeclaration.simpleName(): String = simpleName.asString()
    private fun KSClassDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSAnnotation.qualifiedName(): String? = annotationType.resolve().declaration.qualifiedName?.asString()

    companion object {
        /**
         * Represents an option key used to enable or disable SQL syntax validation during the processing
         * of repository methods. Methods marked with the SQL validation flag will have their provided SQL
         * queries checked for syntax errors before being incorporated into the generated code.
         *
         * This key is typically used internally by the code generator to determine whether to invoke
         * the SQL syntax validation logic.
         */
        private const val VALIDATE_SQL_SYNTAX_OPTION: String = "validate-sql-syntax"

        /**
         * Represents the option key used to enable or disable SQL schema validation
         * during the repository processing phase. When this option is set, the
         * processor validates the defined schema against the repository's domain
         * and query definitions to ensure consistency and correctness.
         */
        private const val VALIDATE_SQL_SCHEMA_OPTION: String = "validate-sql-schema"

        /**
         * Represents the option key used for specifying the path to schema migration files
         * during repository processing and code generation.
         *
         * This constant is used to configure and resolve the directory containing
         * schema migration scripts, which are typically required for database structure
         * migration or initialization. The value associated with this option is expected
         * to be provided as part of the processing environment or tool configuration.
         */
        private const val SCHEMA_MIGRATIONS_PATH_OPTION: String = "schema-migrations-path"
    }
}
