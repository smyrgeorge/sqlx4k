package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSValueArgument
import com.google.devtools.ksp.symbol.KSValueParameter
import com.google.devtools.ksp.validate
import io.github.smyrgeorge.sqlx4k.Statement
import java.io.OutputStream

class RepositoryProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    /**
     * Processes repository symbols annotated with a specific annotation, validates these symbols,
     * and generates Kotlin code for their associated functionality. The generated code is written
     * to a new file using a specified file name and package.
     *
     * @param resolver The `Resolver` instance used to discover and resolve symbols annotated
     *                 with the specified repository annotation.
     * @return A list of `KSAnnotated` symbols that could not be processed due to validation errors.
     */
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val repoSymbols = resolver
            .getSymbolsWithAnnotation(TypeNames.REPOSITORY_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
        if (!repoSymbols.iterator().hasNext()) return emptyList()

        val outputPackage = options[TableProcessor.PACKAGE_OPTION]
            ?: error("Missing ${TableProcessor.PACKAGE_OPTION} option")
        logger.info("[RepositoryProcessor] Output package: $outputPackage")

        val useContextParameters = options[ENABLE_CONTEXT_PARAMETERS_OPTION]?.toBoolean() ?: false
        logger.info("[RepositoryProcessor] Enable context parameters: $useContextParameters")

        val globalCheckSqlSyntax = options[VALIDATE_SQL_SYNTAX_OPTION]?.toBoolean() ?: true
        logger.info("[RepositoryProcessor] Validate SQL syntax: $globalCheckSqlSyntax")

        val globalCheckSqlSchema = options[VALIDATE_SQL_SCHEMA_OPTION]?.toBoolean() ?: false
        logger.info("[RepositoryProcessor] Validate SQL schema: $globalCheckSqlSchema")
        val schemaMigrationsPath = options[SCHEMA_MIGRATIONS_PATH_OPTION] ?: "./set-the-path-to-schema-migrations"

        // Load schemas.
        if (globalCheckSqlSchema) SqlValidator.loadSchema(schemaMigrationsPath)

        val file: OutputStream = codeGenerator.createNewFile(
            // Make sure to associate the generated file with sources to keep/maintain it across incremental builds.
            // Learn more about incremental processing in KSP from the official docs:
            // https://kotlinlang.org/docs/ksp-incremental.html
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = outputPackage,
            fileName = OUTPUT_FILENAME
        )

        file += "// Generated by sqlx4k-codegen (RepositoryProcessor)\n"
        @Suppress("DuplicatedCode")
        file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\", \"SqlDialectInspection\")\n\n"
        file += "package $outputPackage\n\n"
        file += "import ${TypeNames.STATEMENT}\n"
        file += "import ${TypeNames.QUERY_EXECUTOR}\n"

        // For each repository interface, find methods annotated with @Query
        val validatedRepos = repoSymbols.filter { it.validate() }
        validatedRepos.forEach { repo ->
            if (repo.classKind != ClassKind.INTERFACE)
                error("@Repository is only supported on interfaces (${repo.qualifiedName()}).")

            // Extract domain and mapper from @Repository annotation on the interface
            val (domainDecl, mapperTypeName) = parseRepositoryAnnotation(repo, useContextParameters)

            // Find all methods declared in the interface
            val fnsAll = repo.declarations.filterIsInstance<KSFunctionDeclaration>().toList()

            // Determine implementation class name
            val implName = repo.simpleName() + "Impl"
            logger.info("[RepositoryProcessor] Generating implementation object $implName for ${repo.qualifiedName()}")

            // Emit class header
            file += "\nobject $implName : ${repo.qualifiedName()} {\n"

            // Generate @Query-based methods according to prefixes:
            // findAll/findAllBy/findOneBy/deleteBy/countBy/execute and also *All variants
            fnsAll
                .filter { fn -> fn.annotations.any { it.qualifiedName() == TypeNames.QUERY_ANNOTATION } }
                .forEach { fn ->
                    val queryAnn = fn.annotations.first { it.qualifiedName() == TypeNames.QUERY_ANNOTATION }
                    val localCheckSyntax = queryAnn.arguments
                        .firstOrNull { it.name?.asString() == "checkSyntax" }
                        ?.value as? Boolean ?: true
                    val localCheckSchema = queryAnn.arguments
                        .firstOrNull { it.name?.asString() == "checkSchema" }
                        ?.value as? Boolean ?: true
                    val doCheckSyntax = globalCheckSqlSyntax && localCheckSyntax
                    val doCheckSchema = globalCheckSqlSchema && localCheckSchema
                    emitQueryMethod(
                        file = file,
                        fn = fn,
                        validateSyntax = doCheckSyntax,
                        validateSchema = doCheckSchema,
                        mapperTypeName = mapperTypeName,
                        domainDecl = domainDecl,
                        useContextParameters = useContextParameters
                    )
                }

            // Generate CRUD methods: insert/update/delete;
            // Interface must implement CrudRepository<Domain> which we already validated.
            emitCrudMethods(
                file = file,
                domainDecl = domainDecl,
                mapperTypeName = mapperTypeName,
                useContextParameters = useContextParameters
            )
            file += "}\n"
        }
        file.close()

        val unableToProcess = repoSymbols.filterNot { it.validate() }.toList()
        return unableToProcess
    }

    /**
     * Represents the valid prefixes for repository method names in the `RepositoryProcessor` class.
     *
     * These prefixes define the type of operation that a repository method performs, such as finding,
     * deleting, counting, or executing operations on a domain model. The primary usage of this enum
     * is to map method names to their corresponding behavior and ensure methods adhere to the expected
     * naming conventions in the repository interface.
     *
     * The valid prefixes are:
     * - `FIND_ALL`: Indicates methods that fetch all instances of a domain model.
     * - `DELETE_ALL`: Indicates methods that delete all instances of a domain model.
     * - `COUNT_ALL`: Indicates methods that count all instances of a domain model.
     * - `FIND_ALL_BY`: Indicates methods that fetch multiple instances of a domain model based on certain conditions.
     * - `FIND_ONE_BY`: Indicates methods that fetch a single instance of a domain model based on certain conditions.
     * - `DELETE_BY`: Indicates methods that delete instances of a domain model based on certain conditions.
     * - `COUNT_BY`: Indicates methods that count instances of a domain model based on certain conditions.
     * - `EXECUTE`: Indicates methods that perform a custom execution, typically associated with annotated SQL queries.
     *
     * This enum is used internally by the `RepositoryProcessor` to parse method names, validate method
     * signatures, and generate the appropriate method implementations for repository interfaces.
     */
    private enum class Prefix {
        FIND_ONE_BY,
        FIND_ALL_BY,
        FIND_ALL,
        DELETE_BY,
        DELETE_ALL,
        COUNT_BY,
        COUNT_ALL,
        EXECUTE
    }

    /**
     * Parses the method name to determine its prefix and maps it to the corresponding `Prefix` enumeration value.
     * The method identifies valid repository method prefixes such as `findAll`, `deleteAll`, `countAll`, and more,
     * as well as prefixes that start with specific patterns like `findAllBy`, `findOneBy`, etc.
     * If the method name doesn't match any valid prefix, an error is thrown.
     *
     * @param name The name of the repository method that needs to be parsed.
     * @return The detected `Prefix` value corresponding to the method prefix.
     * @throws IllegalStateException if the method name does not correspond to a valid repository method prefix.
     */
    private fun parseMethodPrefix(name: String): Prefix = when {
        name == "findAll" -> Prefix.FIND_ALL
        name == "deleteAll" -> Prefix.DELETE_ALL
        name == "countAll" -> Prefix.COUNT_ALL
        name.startsWith("findAllBy") -> Prefix.FIND_ALL_BY
        name.startsWith("findOneBy") -> Prefix.FIND_ONE_BY
        name.startsWith("deleteBy") -> Prefix.DELETE_BY
        name.startsWith("countBy") -> Prefix.COUNT_BY
        name.startsWith("execute") -> Prefix.EXECUTE
        else -> error("Invalid repository method name '$name'. Must be one of: findAll, deleteAll, countAll or start with: findAllBy, findOneBy, deleteBy, countBy, execute.")
    }

    /**
     * Parses the `@Repository` annotation on the provided repository interface, validates its conformance to the
     * expected structure, and extracts the associated domain type and mapper information.
     *
     * This method ensures that the annotated repository interface extends the correct base interface
     * (e.g., `CrudRepository` or `ContextCrudRepository`) with a valid domain type parameter. Additionally,
     * it verifies that the domain type is annotated with `@Table` and that a mapper is explicitly declared within
     * the `@Repository` annotation.
     *
     * @param repo The repository interface represented as a `KSClassDeclaration`. This class declaration must
     *             be annotated with `@Repository` and implement the appropriate `CrudRepository` interface.
     * @param useContextParameters A flag indicating whether the `ContextCrudRepository` interface
     *                              is being used instead of the standard `CrudRepository`.
     * @return A pair containing the `KSClassDeclaration` of the domain type associated with the repository and
     *         the fully qualified name of the mapper type specified in the `@Repository` annotation.
     * @throws IllegalStateException if the repository interface does not conform to the expected structure, such as
     *         - Missing `@Repository` annotation
     *         - Not extending the appropriate `CrudRepository` interface
     *         - Incorrectly specified domain type
     *         - Domain type not annotated with `@Table`
     *         - Missing or unresolved mapper type in the `@Repository` annotation
     */
    private fun parseRepositoryAnnotation(
        repo: KSClassDeclaration,
        useContextParameters: Boolean
    ): Pair<KSClassDeclaration, String> {
        fun implementsCrudRepository(repo: KSClassDeclaration): KSClassDeclaration {
            val repoTypeName =
                if (useContextParameters) TypeNames.CONTEXT_CRUD_REPOSITORY
                else TypeNames.CRUD_REPOSITORY
            val repoSimpleName = repoTypeName.substringAfterLast(".")
            // find CrudRepository<T> or ContextCrudRepository<T>
            val st = repo.superTypes.map { it.resolve() }
                .firstOrNull { it.declaration.qualifiedName() == repoTypeName }
                ?: error("@Repository interface ${repo.qualifiedName()} must extend $repoTypeName<T>")
            val typeArg = st.arguments.firstOrNull()?.type?.resolve()
                ?: error("${repo.qualifiedName()} implements $repoSimpleName without type argument; expected $repoSimpleName<T>")
            val domainDecl = typeArg.declaration as? KSClassDeclaration
                ?: error("$repoSimpleName type argument must be a class on ${repo.qualifiedName()}")
            // ensure @Table
            val hasTable = domainDecl.annotations.any {
                val qn = it.qualifiedName()
                qn == TypeNames.TABLE_ANNOTATION
            }
            if (!hasTable) error("$repoSimpleName generic parameter must be @Table-annotated (${domainDecl.qualifiedName()})")
            return domainDecl
        }

        val repoAnn = repo.annotations.firstOrNull { it.qualifiedName() == TypeNames.REPOSITORY_ANNOTATION }
            ?: error("Missing @Repository annotation on interface ${repo.qualifiedName()}")

        // Enforce that the interface extends CrudRepository<T> and derive domain from T
        val domainDecl = implementsCrudRepository(repo)

        val mapperArg: KSValueArgument? = repoAnn.arguments.firstOrNull { it.name?.asString() == "mapper" }
        val mapperKSType = mapperArg?.value as? KSType
            ?: error("@Repository must declare a mapper, e.g. @Repository(mapper = FooRowMapper::class) on ${repo.qualifiedName()}")
        val mapperTypeName = mapperKSType.declaration.qualifiedName()
            ?: error("Unable to resolve mapper type for ${repo.qualifiedName()}")
        return domainDecl to mapperTypeName
    }

    /**
     * Validates the context parameter for a given function declaration based on the specified mode.
     *
     * @param fn The function declaration to validate.
     * @param useContextParameters A flag indicating whether context parameters mode is enabled.
     */
    private fun validateContextParameter(
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val params = fn.parameters
        if (useContextParameters) {
            // TODO: somehow validate that method has context(context: QueryExecutor).
            // Ensure there is no explicit parameter of type QueryExecutor named 'context'
            val hasExplicitContextParam = params.any { p ->
                val pType = p.type.resolve()
                val qn = pType.declaration.qualifiedName()
                val pName = p.name?.asString()
                qn == TypeNames.QUERY_EXECUTOR && pName == "context"
            }
            if (hasExplicitContextParam) {
                error("Repository method '$name' must not declare parameter 'context: ${TypeNames.QUERY_EXECUTOR}' when using context parameters")
            }
            return
        }
        // Non-context-parameters mode: the first parameter must be 'context: QueryExecutor'
        if (params.isEmpty())
            error("Repository method '$name' must declare first parameter 'context: ${TypeNames.QUERY_EXECUTOR}'")
        val first = params.first()
        val firstName = first.name?.asString()
            ?: error("Repository method '$name' first parameter must be named 'context'")
        if (firstName != "context")
            error("Repository method '$name' first parameter must be named 'context'")
        val firstType = first.type.resolve()
        val firstQn = firstType.declaration.qualifiedName()
            ?: error("Unable to resolve type of first parameter for method '$name'")
        if (firstQn != TypeNames.QUERY_EXECUTOR || firstType.isMarkedNullable)
            error("Repository method '$name' first parameter must be non-null ${TypeNames.QUERY_EXECUTOR}")
    }

    /**
     * Validates the return type of a repository method based on its prefix and domain type.
     *
     * @param prefix The prefix of the method, used to determine its behavior and expected return type.
     * @param fn The function declaration representing the repository method to validate.
     * @param domainDecl The class declaration of the repository's domain type.
     */
    private fun validateReturnType(
        prefix: Prefix,
        fn: KSFunctionDeclaration,
        domainDecl: KSClassDeclaration
    ) {
        val name = fn.simpleName()
        val returnType = fn.returnType?.resolve()
            ?: error("Unable to resolve return type for method '$name'")
        val resultQName = returnType.declaration.qualifiedName()
            ?: error("Unable to resolve return type declaration for method '$name'")
        if (resultQName != TypeNames.KOTLIN_RESULT)
            error("Repository method '$name' must return kotlin.Result<...> but returns '$returnType'")
        val r0 = returnType.arguments.firstOrNull()?.type?.resolve()
            ?: error("Repository method '$name' must return kotlin.Result<...> with a type argument")

        fun ensureDomain(inner: KSType, allowNullable: Boolean) {
            val innerDecl = inner.declaration as? KSClassDeclaration
                ?: error("Unable to resolve inner domain type for method '$name'")
            val innerQn = innerDecl.qualifiedName()
                ?: error("Unable to resolve inner domain type name for method '$name'")
            val domainQn = domainDecl.qualifiedName()
                ?: error("Unable to resolve repository domain type name")
            if (innerQn != domainQn)
                error("Method '$name' must use repository domain type '$domainQn' but found '$innerQn'")
            if (!allowNullable && inner.isMarkedNullable)
                error("Method '$name' domain return type must be non-nullable")
        }

        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> {
                val listQn = r0.declaration.qualifiedName()
                    ?: error("Unable to resolve inner type for method '$name'")
                if (listQn != TypeNames.KOTLIN_LIST || r0.isMarkedNullable)
                    error("Method '$name' must return Result<List<T>> where T is the repository domain type")
                val tArg = r0.arguments.firstOrNull()?.type?.resolve()
                    ?: error("Method '$name' must return Result<List<T>> with a generic argument")
                ensureDomain(tArg, allowNullable = false)
            }

            Prefix.FIND_ONE_BY -> {
                ensureDomain(r0.makeNotNullable(), allowNullable = true)
                if (!r0.isMarkedNullable)
                    error("Method '$name' must return Result<T?> where T is the repository domain type")
            }

            Prefix.DELETE_ALL, Prefix.COUNT_ALL, Prefix.DELETE_BY, Prefix.COUNT_BY, Prefix.EXECUTE -> {
                val qn0 = r0.declaration.qualifiedName()
                    ?: error("Unable to resolve inner type for method '$name'")
                if (qn0 != TypeNames.KOTLIN_LONG || r0.isMarkedNullable)
                    error("Method '$name' with prefix '${prefix.name.lowercase()}' must return kotlin.Result<kotlin.Long>")
            }
        }
    }

    /**
     * Validates the arity of the parameters in a repository method based on its prefix and other constraints.
     *
     * @param prefix The prefix of the method, which determines the expected parameter count and validation rules.
     * @param fn The function declaration to validate.
     * @param useContextParameters A flag indicating whether the method uses context parameters.
     *      If true, context parameters are excluded from standard parameter arity validation.
     */
    private fun validateParameterArity(
        prefix: Prefix,
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val params = fn.parameters
        val nonContextCount = if (useContextParameters) params.size else params.size - 1
        when (prefix) {
            Prefix.FIND_ALL, Prefix.DELETE_ALL, Prefix.COUNT_ALL -> if (nonContextCount != 0) error("Method '$name' must not have parameters other than context")
            Prefix.FIND_ALL_BY, Prefix.FIND_ONE_BY, Prefix.DELETE_BY, Prefix.COUNT_BY -> if (nonContextCount < 1) error(
                "Method '$name' must have more than one argument (at least one after context)"
            )

            Prefix.EXECUTE -> {}
        }
    }

    /**
     * Validates the parameters in a repository method in the context of a SQL query.
     *
     * This method checks the compatibility between the parameters declared in a repository method
     * and the named parameters used in the associated SQL query.
     *
     * @param sql The SQL query string associated with the repository method.
     * @param fn The repository method declaration (`KSFunctionDeclaration`) containing parameters to be validated.
     * @param useContextParameters A flag indicating whether the method uses context parameters. If `true`,
     *                              the first parameter (assumed to be the context parameter) is excluded from validation.
     * @throws IllegalStateException If:
     * - Positional parameters are used in the SQL query.
     * - The number of method parameters does not match the number of named parameters in the SQL query.
     * - Any method parameter is missing a corresponding named parameter in the SQL query.
     * - Any method parameter lacks a name.
     */
    fun validateParameters(
        sql: String,
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val statement = Statement.create(sql)
        if (statement.extractedPositionalParameters > 0)
            error("Method '$name' uses positional parameters in @Query (only named parameters are supported).")
        // Exclude 'context' argument.
        val parameters = if (useContextParameters) fn.parameters else fn.parameters.drop(1)
        if (parameters.size != statement.extractedNamedParameters.size)
            error("Method '$name' has ${parameters.size} parameters but @Query statement has ${statement.extractedNamedParameters.size} named parameters.")
        parameters.forEach { p ->
            val pName = p.name?.asString()
                ?: error("All query parameters must be named when using namedParameters support")
            if (!statement.extractedNamedParameters.contains(pName))
                error("Method '$name' has parameter '$pName' but @Query statement does not contain a named parameter with that name.")
        }
    }

    /**
     * Emits named parameter bindings for a given list of parameters into the specified output stream.
     * This method assumes that parameters after the first one must be named and generates binding statements accordingly.
     *
     * @param file The OutputStream where the named parameter-binding statements will be written.
     * @param params A list of KSValueParameter objects representing the parameters for which bindings are generated. The first parameter is excluded from processing.
     */
    private fun emitNamedParameterBindings(
        file: OutputStream,
        params: List<KSValueParameter>
    ) {
        params.drop(1).forEach { p ->
            val pName = p.name?.asString()
                ?: error("All query parameters must be named when using namedParameters support")
            file += "        statement.bind(\"$pName\", $pName)\n"
        }
    }

    /**
     * Generates the implementation of a repository method annotated with `@Query`.
     *
     * @param file The output stream where the generated method will be written.
     * @param fn The function declaration representing the annotated method.
     * @param validateSyntax A flag indicating whether the SQL syntax should be validated.
     * @param validateSchema A flag indicating whether the SQL query should be validated against the schema.
     * @param mapperTypeName The name of the mapper used for mapping query results.
     * @param domainDecl The class declaration representing the domain entity associated with this repository.
     * @param useContextParameters A flag indicating whether context parameters are used in the generated method.
     */
    private fun emitQueryMethod(
        file: OutputStream,
        fn: KSFunctionDeclaration,
        validateSyntax: Boolean,
        validateSchema: Boolean,
        mapperTypeName: String,
        domainDecl: KSClassDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val prefix: Prefix = parseMethodPrefix(name)
        logger.info("[RepositoryProcessor] Generating @Query method: $name")

        val sql: String = fn.annotations.first { it.qualifiedName() == TypeNames.QUERY_ANNOTATION }
            .arguments.firstOrNull { it.name?.asString() == "value" }
            ?.value as? String
            ?: error("Unable to generate query method (could not extract sql query from the @Query): $fn")

        val params = fn.parameters
        val paramSig = params.joinToString { p ->
            val pName = p.name?.asString() ?: "p"
            val pType = p.type.toString()
            "$pName: $pType"
        }

        validateContextParameter(fn, useContextParameters)
        validateParameterArity(prefix, fn, useContextParameters)
        validateParameters(sql, fn, useContextParameters)
        validateReturnType(prefix, fn, domainDecl)
        if (validateSyntax) SqlValidator.validateQuerySyntax(fn.simpleName(), sql)
        if (validateSchema) SqlValidator.validateQuerySchema(fn.simpleName(), sql)

        logger.info("[RepositoryProcessor] Emitting method '$name' with prefix ${prefix.name} in ${domainDecl.qualifiedName()} using mapper $mapperTypeName")

        // Generate KDoc
        file += "    /**\n"
        file += "     * Generated implementation of [$name]\n"
        file += "     *\n"
        file += "     * SQL: `$sql`\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        params.drop(if (useContextParameters) 0 else 1).forEach { p ->
            val pName = p.name?.asString() ?: "param"
            file += "     * @param $pName Query parameter\n"
        }
        val returnDesc = when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> "Result containing list of ${domainDecl.simpleName()} entities"
            Prefix.FIND_ONE_BY -> "Result containing a single ${domainDecl.simpleName()} entity or null if not found"
            Prefix.DELETE_ALL, Prefix.DELETE_BY, Prefix.EXECUTE -> "Result containing the number of affected rows"
            Prefix.COUNT_ALL, Prefix.COUNT_BY -> "Result containing the count"
        }
        file += "     * @return $returnDesc, or an error if the operation fails\n"
        file += "     */\n"

        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
        }
        file += "    override suspend fun $name($paramSig) = run {\n"
        file += "        // language=SQL\n"
        file += "        val statement = Statement.create(\"$sql\")\n"
        emitNamedParameterBindings(file, params)

        val contextParamName =
            if (useContextParameters) "context"
            else params.firstOrNull()?.name?.asString() ?: "context"

        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> {
                file += "        $contextParamName.fetchAll(statement, $mapperTypeName)\n"
            }

            Prefix.FIND_ONE_BY -> {
                file += "        $contextParamName.fetchAll(statement, $mapperTypeName).map { list ->\n"
                file += "            when (list.size) {\n"
                file += "                0 -> null\n"
                file += "                1 -> list.first()\n"
                file += "                else -> return@run Result.failure(IllegalStateException(\"findOneBy query returned more than one row\"))\n"
                file += "            }\n"
                file += "        }\n"
            }

            Prefix.DELETE_ALL, Prefix.DELETE_BY, Prefix.EXECUTE -> {
                file += "        $contextParamName.execute(statement)\n"
            }

            Prefix.COUNT_ALL, Prefix.COUNT_BY -> {
                file += "        $contextParamName.fetchAll(statement).map { rs ->\n"
                file += "            val row = rs.firstOrNull()\n"
                file += "                ?: return@run Result.failure(IllegalStateException(\"Count query returned no rows\"))\n"
                file += "            row.get(0).asString().toLong()\n"
                file += "        }\n"
            }
        }
        file += "    }\n"
    }

    /**
     * Generates CRUD methods (insert, update, delete, save) for the provided domain class and writes
     * the method definitions to the specified output stream.
     *
     * @param file the output stream where the generated CRUD methods will be written
     * @param domainDecl the class declaration of the domain object for which CRUD methods are generated
     * @param mapperTypeName the name of the mapper type used to map query results to the domain object
     * @param useContextParameters whether to include `QueryExecutor` as a context parameter in the method signatures
     */
    private fun emitCrudMethods(
        file: OutputStream,
        domainDecl: KSClassDeclaration,
        mapperTypeName: String,
        useContextParameters: Boolean
    ) {
        val domainQn = domainDecl.qualifiedName() ?: error("Cannot resolve domain type name")
        val domainSimpleName = domainDecl.simpleName()
        logger.info("[RepositoryProcessor] Generating CRUD methods for $domainQn")

        // insert
        logger.info("[RepositoryProcessor] Emitting CRUD method: insert($domainQn)")
        file += "    /**\n"
        file += "     * Inserts a new $domainSimpleName entity into the database.\n"
        file += "     *\n"
        file += "     * Executes an INSERT statement and returns the inserted entity with any\n"
        file += "     * generated values (e.g., auto-incremented IDs) populated.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to insert\n"
        file += "     * @return Result containing the inserted $domainSimpleName with generated values,\n"
        file += "     *         or an error if the insert operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun insert(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun insert(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        file += "        val statement = entity.insert()\n"
        file += "        context.fetchAll(statement, $mapperTypeName).map { list ->\n"
        file += "            val one = list.firstOrNull()\n"
        file += "                ?: return@run Result.failure(IllegalStateException(\"Insert query returned no rows\"))\n"
        file += "            one\n"
        file += "        }\n"
        file += "    }\n"

        // update
        logger.info("[RepositoryProcessor] Emitting CRUD method: update($domainQn)")
        file += "    /**\n"
        file += "     * Updates an existing $domainSimpleName entity in the database.\n"
        file += "     *\n"
        file += "     * Executes an UPDATE statement based on the entity's ID and returns\n"
        file += "     * the updated entity with any modified values.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to update\n"
        file += "     * @return Result containing the updated $domainSimpleName entity,\n"
        file += "     *         or an error if the update operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun update(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun update(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        file += "        val statement = entity.update()\n"
        file += "        context.fetchAll(statement, $mapperTypeName).map { list ->\n"
        file += "            val one = list.firstOrNull()\n"
        file += "                ?: return@run Result.failure(IllegalStateException(\"Update query returned no rows\"))\n"
        file += "            one\n"
        file += "        }\n"
        file += "    }\n"

        // delete
        logger.info("[RepositoryProcessor] Emitting CRUD method: delete($domainQn)")
        file += "    /**\n"
        file += "     * Deletes a $domainSimpleName entity from the database.\n"
        file += "     *\n"
        file += "     * Executes a DELETE statement based on the entity's ID.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to delete\n"
        file += "     * @return Result containing Unit on success,\n"
        file += "     *         or an error if the delete operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun delete(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun delete(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        file += "        val statement = entity.delete()\n"
        file += "        context.execute(statement).map { kotlin.Unit }\n"
        file += "    }\n"

        // save
        logger.info("[RepositoryProcessor] Emitting CRUD method: save($domainQn)")
        file += "    /**\n"
        file += "     * Saves a $domainSimpleName entity to the database.\n"
        file += "     *\n"
        file += "     * Automatically determines whether to INSERT (if entity is new) or\n"
        file += "     * UPDATE (if entity already exists) based on the ID field value.\n"
        file += "     * For Int IDs, 0 indicates a new entity. For Long IDs, 0L indicates new.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to save\n"
        file += "     * @return Result containing the saved $domainSimpleName entity,\n"
        file += "     *         or an error if the save operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun save(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun save(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        val idProp: KSPropertyDeclaration? = domainDecl.getAllProperties().firstOrNull { p ->
            p.annotations.any { it.qualifiedName() == TypeNames.ID_ANNOTATION }
        }
        if (idProp == null) {
            file += "        error(\"No @Id property found in ${domainDecl.qualifiedName()}\")\n"
            file += "    }\n"
        } else {
            val idName = idProp.simpleName.getShortName()
            when (val idQn = idProp.type.resolve().declaration.qualifiedName()) {
                TypeNames.KOTLIN_INT, TypeNames.KOTLIN_LONG -> {
                    val zeroLiteral = if (idQn == TypeNames.KOTLIN_INT) "0" else "0L"
                    file += if (useContextParameters) {
                        "        if (entity.$idName == $zeroLiteral) insert(entity) else update(entity)\n"
                    } else {
                        "        if (entity.$idName == $zeroLiteral) insert(context, entity) else update(context, entity)\n"
                    }
                    file += "    }\n"
                }

                else -> {
                    file += "        error(\"@Id property '$idName' must be of type Int or Long in ${domainDecl.qualifiedName()}\")\n"
                    file += "    }\n"
                }
            }
        }
    }

    operator fun OutputStream.plusAssign(str: String): Unit = write(str.toByteArray())
    private fun KSDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSClassDeclaration.simpleName(): String = simpleName.asString()
    private fun KSFunctionDeclaration.simpleName(): String = simpleName.asString()
    private fun KSClassDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSAnnotation.qualifiedName(): String? = annotationType.resolve().declaration.qualifiedName?.asString()

    companion object {
        /**
         * The default output file name used for generating repository implementations.
         * This constant is used in the code generation process to create output files
         * with a standardized and consistent naming convention.
         */
        private const val OUTPUT_FILENAME = "GeneratedRepositories"

        /**
         * Represents an option key used to enable or disable SQL syntax validation during the processing
         * of repository methods. Methods marked with the SQL validation flag will have their provided SQL
         * queries checked for syntax errors before being incorporated into the generated code.
         *
         * This key is typically used internally by the code generator to determine whether to invoke
         * the SQL syntax validation logic.
         */
        private const val VALIDATE_SQL_SYNTAX_OPTION: String = "validate-sql-syntax"

        /**
         * Represents the option key used to enable or disable SQL schema validation
         * during the repository processing phase. When this option is set, the
         * processor validates the defined schema against the repository's domain
         * and query definitions to ensure consistency and correctness.
         */
        private const val VALIDATE_SQL_SCHEMA_OPTION: String = "validate-sql-schema"

        /**
         * Represents the option key used for specifying the path to schema migration files
         * during repository processing and code generation.
         *
         * This constant is used to configure and resolve the directory containing
         * schema migration scripts, which are typically required for database structure
         * migration or initialization. The value associated with this option is expected
         * to be provided as part of the processing environment or tool configuration.
         */
        private const val SCHEMA_MIGRATIONS_PATH_OPTION: String = "schema-migrations-path"

        /**
         * Represents the option flag to enable context parameters for methods in repositories.
         * When this option is enabled, repository methods are expected to validate the presence
         * and correctness of a mandatory `context` parameter, which must be an instance of
         * `io.github.smyrgeorge.sqlx4k.QueryExecutor`.
         */
        private const val ENABLE_CONTEXT_PARAMETERS_OPTION: String = "enable-context-parameters"
    }
}
