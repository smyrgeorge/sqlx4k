package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

@Suppress("DuplicatedCode")
class RepositoryProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val repoSymbols = resolver
            .getSymbolsWithAnnotation(REPOSITORY_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()

        if (!repoSymbols.iterator().hasNext()) return emptyList()

        val outputPackage = options[TableProcessor.PACKAGE_OPTION]
            ?: error("Missing ${TableProcessor.PACKAGE_OPTION} option")

        val outputFilename = options[FILENAME_OPTION] ?: "GeneratedRepositories"

        val file: OutputStream = codeGenerator.createNewFile(
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = outputPackage,
            fileName = outputFilename
        )

        file += "// Generated by sqlx4k-codegen\n"
        file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\")\n\n"
        file += "package $outputPackage\n"
        file += "\nimport io.github.smyrgeorge.sqlx4k.Statement\n"

        // For each repository interface, find methods annotated with @Query
        val validatedRepos = repoSymbols.filter { it.validate() }
        validatedRepos.forEach { iface ->
            if (iface.classKind != ClassKind.INTERFACE) {
                error("@Repository is only supported on interfaces (${iface.qualifiedName?.asString()}).")
            }

            val fns = iface.declarations
                .filterIsInstance<KSFunctionDeclaration>()
                .filter { fn -> fn.annotations.any { it.name() == QUERY_ANNOTATION_NAME } }
                .toList()

            if (fns.isEmpty()) return@forEach

            // Determine implementation class name
            val implName = iface.name() + "Impl"

            // Emit class header
            file += "\nobject $implName : ${iface.qualifiedName?.asString()} {\n"

            // For each function, generate an override that constructs a Statement from @Query
            fns.forEach { fn ->
                val ann: KSAnnotation = fn.annotations.first { it.name() == QUERY_ANNOTATION_NAME }
                val sqlArg: KSValueArgument = ann.arguments.first { it.name?.asString() == "value" }
                val sql = sqlArg.value as String

                // Build method signature
                val name = fn.simpleName.asString()
                val params = fn.parameters
                val paramSig = params.joinToString { p ->
                    val pName = p.name?.asString() ?: "p"
                    val pType = p.type.resolve().declaration.qualifiedName?.asString()
                        ?: p.type.toString()
                    "$pName: $pType"
                }

                file += "    override suspend fun $name($paramSig): Statement {\n"
                file += "        // language=SQL\n"
                file += "        val statement = Statement.create(\"$sql\")\n"

                // Bind parameters in order
                params.forEachIndexed { index, p ->
                    val pName = p.name?.asString() ?: "p$index"
                    file += "        statement.bind($index, $pName)\n"
                }

                file += "        return statement\n"
                file += "    }\n"
            }

            file += "}\n"
        }

        file.close()

        val unableToProcess = repoSymbols.filterNot { it.validate() }.toList()
        return unableToProcess
    }

    private fun KSAnnotation.name(): String = shortName.asString()
    private fun KSClassDeclaration.name(): String = simpleName.asString()

    operator fun OutputStream.plusAssign(str: String) {
        write(str.toByteArray())
    }

    companion object {
        /**
         * The option key used to specify the output filename for the generated SQL classes.
         */
        private const val FILENAME_OPTION = "output-filename"
        private const val QUERY_ANNOTATION_NAME = "Query"
        private const val REPOSITORY_ANNOTATION = "io.github.smyrgeorge.sqlx4k.annotation.Repository"
    }
}
