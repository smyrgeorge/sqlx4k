package io.github.smyrgeorge.sqlx4k.examples.postgres

import io.github.smyrgeorge.sqlx4k.Connection
import io.github.smyrgeorge.sqlx4k.QueryExecutor
import io.github.smyrgeorge.sqlx4k.Statement
import io.github.smyrgeorge.sqlx4k.impl.coroutines.TransactionContext
import io.github.smyrgeorge.sqlx4k.postgres.IPostgresSQL
import io.github.smyrgeorge.sqlx4k.postgres.pgmq.PgMqClient
import io.github.smyrgeorge.sqlx4k.postgres.pgmq.PgMqConsumer
import kotlinx.coroutines.delay
import kotlin.time.Duration.Companion.seconds

object Examples {
    /**
     * Executes a series of database operations and examples for demonstrating the usage of
     * PostgreSQL database integration through various functionalities.
     *
     * @param db The PostgreSQL database instance used for executing queries and performing operations.
     * @param repo The repository instance used for CRUD operations and repository-specific examples.
     */
    suspend fun runAll(db: IPostgresSQL, repo: Sqlx4kRepository) {
        delay(2000)
        migrate(db)
        delay(1000)
        exampleBasics(db)
        delay(1000)
        examplePreparedStatements(db)
        delay(1000)
        exampleStatementBinding()
        delay(1000)
        exampleConnectionManagement(db)
        delay(1000)
        exampleTransactions(db, repo)
        delay(1000)
        exampleTransactionContext(db)
        delay(1000)
        exampleCrudRepository(db, repo)
        delay(1000)
        exampleAutoGeneratedRepository(db, repo)
        delay(1000)
        exampleListenNotify(db)
    }

    suspend fun runPgmq(db: IPostgresSQL) {
        println("\n=== PgMq ===")
        val queue = PgMqClient.Queue(name = "test_queue")
        val pgmq = PgMqClient(db).apply { create(queue) }
        val consumer = PgMqConsumer(
            pgmq = pgmq,
            options = PgMqConsumer.Options(queue = queue.name),
            onMessage = { println("Message received: $it") },
            onFaiToRead = { println("Error (onFaiToRead): $it") },
            onFailToProcess = { println("Error (onFailToProcess): $it") },
            onFaiToAck = { println("Error (onFaiToAck): $it") },
            onFaiToNack = { println("Error (onFaiToNack): $it") },
        )
        println("Consumer $consumer started.")
        delay(30.seconds)
        consumer.stop()
        println("Consumer stopped.")
    }

    /**
     * Executes database migrations by applying SQL scripts located in the specified directory.
     *
     * This function initiates the migration process by utilizing the `migrate` method of the
     * provided database instance. It processes SQL scripts found in the specified directory
     * and is used to apply schema or data alterations to the database.
     *
     * @param db An instance of `IPostgresSQL` used for executing the migration.
     * @param path The file path to the directory containing migration scripts. Defaults to "./db/migrations".
     */
    suspend fun migrate(db: IPostgresSQL, path: String = "./db/migrations") {
        println("\n=== Migrate ===")
        val res = db.migrate(
            path = path,
            afterStatementExecution = { s, d -> println("Migration of statement: $s, took $d") },
            afterFileMigration = { m, d -> println("Migration of file: $m, took $d") }
        ).getOrThrow()
        println("Migration completed. $res")
    }

    /**
     * Demonstrates basic database operations, including table creation, data insertion,
     * and data retrieval using provided QueryExecutor.
     *
     * @param db the QueryExecutor instance used to execute database queries
     */
    suspend fun exampleBasics(db: QueryExecutor) {
        println("\n=== Basics ===")
        db.execute("drop table if exists sqlx4k;").getOrThrow()
        db.execute("create table if not exists sqlx4k(id integer, test text);").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (65, 'test');").getOrThrow()

        val rows = db.fetchAll("select * from sqlx4k;", Sqlx4kRowMapper).getOrThrow()
        println("Rows: $rows")

        db.fetchAll("select 1;").getOrThrow().forEach { println(it) }
        db.fetchAll("select now();").getOrThrow().forEach { println(it) }
        db.fetchAll("select 'testtest', 'test1';").getOrThrow().forEach { println(it) }
    }

    /**
     * Demonstrates usage of prepared statements (with named and positional parameters)
     * in database operations using a QueryExecutor.
     *
     * @param db An instance of QueryExecutor used to execute SQL queries and fetch results.
     */
    suspend fun examplePreparedStatements(db: QueryExecutor) {
        println("\n=== Prepared Statements ===")
        // Ensure data
        db.execute("delete from sqlx4k;").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (65, 'test65'), (66, 'test66');").getOrThrow()

        // Named parameter
        val st1 = Statement
            .create("select * from sqlx4k where id = :id")
            .bind("id", 65)
        val res1 = db.fetchAll(st1, Sqlx4kRowMapper).getOrThrow()
        println("Named params => $res1")

        // Positional parameter
        val st2 = Statement
            .create("select * from sqlx4k where id = ?")
            .bind(0, 66)
        val res2 = db.fetchAll(st2, Sqlx4kRowMapper).getOrThrow()
        println("Positional params => $res2")
    }

    /**
     * Demonstrates binding parameters to SQL statements and rendering them into executable strings.
     *
     * The function showcases the usage of `Statement` creation, parameter binding, and SQL rendering
     * with positional parameter placeholders. It illustrates error handling during the process and logs
     * the output statements or errors accordingly.
     *
     * - A `Statement` is created with placeholder parameters `?` for positional bindings.
     * - Values are bound to these placeholders using the `bind` method.
     * - The statement is rendered into a final SQL string using the `render` method.
     * - On success, the rendered statement is printed, while errors are logged if they occur.
     *
     * This example places emphasis on how to handle SQL statement preparation dynamically and safely
     * by substituting values and escaping appropriately as required.
     */
    fun exampleStatementBinding() {
        println("\n=== Statement binding ===")
        runCatching {
            val st = Statement.create("select * from sqlx4k where id = ?")
                .bind(0, 65)
                .render()
            println("Statement: $st")

            val st1 = Statement.create("? ? ?")
                .bind(0, "test")
                .bind(1, "'test'")
                .bind(2, "';select *;--")
                .render()
            println("Statement: $st1")
        }.onFailure { println("Statement error: ${it.message}") }
    }

    /**
     * Demonstrates connection management by acquiring, using, and releasing a database connection.
     *
     * The method prints the state of the connection pool, executes SQL statements
     * using a dedicated connection, fetches results, and ensures proper resource cleanup.
     *
     * @param db The PostgreSQL database instance to manage connections from.
     */
    suspend fun exampleConnectionManagement(db: IPostgresSQL) {
        println("\n=== Connection management ===")
        println("Pool size: ${db.poolSize()} (idle: ${db.poolIdleSize()})")
        val cn: Connection = db.acquire().getOrThrow()
        try {
            println("Acquired connection. Pool size: ${db.poolSize()} (idle: ${db.poolIdleSize()})")
            // Use the dedicated connection
            cn.execute("delete from sqlx4k;").getOrThrow()
            cn.execute("insert into sqlx4k (id, test) values (10, 'from-conn');").getOrThrow()
            val rows = cn.fetchAll("select * from sqlx4k;", Sqlx4kRowMapper).getOrThrow()
            println("Rows via connection: $rows")
        } finally {
            cn.release().getOrThrow()
            delay(1000) // Ensure that the connection has been released.
            println("Released connection. Pool size: ${db.poolSize()} (idle: ${db.poolIdleSize()})")
        }
    }

    /**
     * Demonstrates the use of transactions, handling rollbacks and commits,
     * and the integration of transactional contexts with a repository.
     *
     * @param db The PostgreSQL database interface used for executing SQL operations and managing transactions.
     * @param repo The repository interface for performing database queries on the "sqlx4k" table.
     */
    suspend fun exampleTransactions(db: IPostgresSQL, repo: Sqlx4kRepository) {
        println("\n=== Transactions ===")
        // Prepare table
        db.execute("delete from sqlx4k;").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (1, 'a');").getOrThrow()

        // Manual begin/rollback
        val tx = db.begin().getOrThrow()
        runCatching {
            tx.execute("insert into sqlx4k (id, test) values (2, 'b');").getOrThrow()
            val inside = repo.findAll(tx).getOrThrow()
            println("Inside manual tx before rollback => $inside")
            error("Force rollback")
        }.onFailure {
            tx.rollback().getOrThrow()
        }
        val afterRollback = repo.findAll(db).getOrThrow()
        println("After rollback => $afterRollback")

        // Using transaction helper (auto-commit)
        db.transaction {
            execute("insert into sqlx4k (id, test) values (3, 'c');").getOrThrow()
            // Demonstrate transactional context by passing `this` (Transaction) to repo
            val inside = repo.findAll(this).getOrThrow()
            println("Inside tx helper => $inside")
        }
        val afterCommit = repo.findAll(db).getOrThrow()
        println("After commit => $afterCommit")
    }

    /**
     * Demonstrates the usage of a `CrudRepository` interface with custom `@Query` methods
     * to interact with a database and perform CRUD operations.
     *
     * @param db The `QueryExecutor` instance used to execute database queries.
     * @param repo The `Sqlx4kRepository` instance providing predefined database operations.
     */
    suspend fun exampleCrudRepository(db: QueryExecutor, repo: Sqlx4kRepository) {
        println("\n=== CrudRepository + @Query ===")

        // Basic seed
        db.execute("delete from sqlx4k;").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (1, 'a'), (2, 'b'), (3, 'c');").getOrThrow()

        // Use provided repository operations (generated on platforms)
        val found1 = repo.findOneById(db, 2).getOrThrow()
        println("findOneById(2) => $found1")

        val all = repo.findAll(db).getOrThrow()
        println("findAll => ${all.size} items: $all")

        val count = repo.countAll(db).getOrThrow()
        println("countAll => $count")
    }

    /**
     * Demonstrates auto-generated CRUD operations (insert, update, save, delete)
     * using the provided database query executor and repository.
     *
     * @param db The database query executor used to perform operations.
     * @param repo The repository handling CRUD operations for the Sqlx4k entity.
     */
    suspend fun exampleAutoGeneratedRepository(db: QueryExecutor, repo: Sqlx4kRepository) {
        println("\n=== Auto-generated CRUD ===")

        val inserted = repo.insert(db, Sqlx4k(id = 123456, test = "test")).getOrThrow()
        println("inserted => $inserted")

        val updated = repo.update(db, inserted.copy(test = "updated")).getOrThrow()
        println("updated => $updated")

        val saved = repo.save(db, updated).getOrThrow()
        println("saved => $saved")

        val byId = repo.findOneById(db, 123456).getOrThrow()
        println("findOneById(123456) => $byId")

        repo.delete(db, saved).getOrThrow()
        val afterDelete = repo.findOneById(db, 123456).getOrThrow()
        println("after delete => $afterDelete")
    }

    /**
     * Demonstrates the usage of a transactional context for handling database operations
     * including nested functions that participate in the same transaction. Executes
     * transaction-related business logic using different transactional scenarios.
     *
     * @param db The database connection implementing the IPostgresSQL interface,
     *           used to manage the transaction and perform database operations.
     */
    suspend fun exampleTransactionContext(db: IPostgresSQL) {
        suspend fun doBusinessLogic() {
            val tx = TransactionContext.current()
            tx.execute("update sqlx4k set test = 'tc-updated' where id = 66;").getOrThrow()
            println("doBusinessLogic updated id=66")
        }

        suspend fun doMoreBusinessLogic(): Unit = TransactionContext.withCurrent {
            // Continue in same tx
            fetchAll("select id, test from sqlx4k where id = 66;", Sqlx4kRowMapper).getOrThrow().also {
                println("doMoreBusinessLogic read => $it")
            }
        }

        suspend fun doExtraBusinessLogic(db: IPostgresSQL): Unit = TransactionContext.withCurrent(db) {
            // If no TransactionContext was present, this would open a new tx; here it reuses the existing one
            fetchAll("select count(*) from sqlx4k;").getOrThrow().also {
                println("doExtraBusinessLogic count rows => $it")
            }
        }

        println("\n=== TransactionContext (coroutines) ===")
        TransactionContext.new(db) {
            // Seed a record and demonstrate nested helpers participating in same tx
            execute("insert into sqlx4k (id, test) values (66, 'tc');").getOrThrow()
            println("Inserted id=66 in TransactionContext")
            doBusinessLogic()
            doMoreBusinessLogic()
            doExtraBusinessLogic(db)
        }
        println("TransactionContext block completed")
    }

    /**
     * Demonstrates an example of using PostgreSQL's `LISTEN` and `NOTIFY` functionality.
     *
     * This method showcases how to listen for notifications on a specific channel and how to send
     * notifications on that channel with given payloads. Notifications received on the channel
     * are processed asynchronously via a callback function.
     *
     * @param db The PostgreSQL database instance implementing the `IPostgresSQL` interface,
     *           used to perform listening and notification operations.
     */
    suspend fun exampleListenNotify(db: IPostgresSQL) {
        println("\n=== Listen / Notify ===")
        val channel = "example_events"

        // Start listening (registers a listener internally, non-blocking)
        db.listen(channel) { n ->
            println("Notification: channel='${n.channel}' payload='${n.value}'")
        }

        // Send notifications
        db.notify(channel, "hello-1")
        db.notify(channel, "hello-2")

        // Give some time for notifications to be delivered
        delay(300)
    }
}
