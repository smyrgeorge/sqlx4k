package io.github.smyrgeorge.sqlx4k.examples.mysql

import io.github.smyrgeorge.sqlx4k.Connection
import io.github.smyrgeorge.sqlx4k.QueryExecutor
import io.github.smyrgeorge.sqlx4k.Statement
import io.github.smyrgeorge.sqlx4k.impl.coroutines.TransactionContext
import io.github.smyrgeorge.sqlx4k.mysql.IMySQL
import kotlinx.coroutines.delay

object Examples {
    /**
     * Executes a series of database operations and examples for demonstrating the usage of
     * MySQL database integration through various functionalities.
     */
    suspend fun runAll(db: IMySQL, repo: Sqlx4kRepository) {
        delay(2000)
        migrate(db)
        delay(1000)
        exampleBasics(db)
        delay(1000)
        examplePreparedStatements(db)
        delay(1000)
        exampleStatementBinding()
        delay(1000)
        exampleConnectionManagement(db)
        delay(1000)
        exampleTransactions(db, repo)
        delay(1000)
        exampleTransactionContext(db)
        delay(1000)
        exampleCrudRepository(db, repo)
        delay(1000)
        exampleAutoGeneratedRepository(db, repo)
    }

    suspend fun migrate(db: IMySQL, path: String = "./db/migrations") {
        println("\n=== Migrate ===")
        val res = db.migrate(
            path = path,
            afterStatementExecution = { s, d -> println("Migration of statement: $s, took $d") },
            afterFileMigration = { m, d -> println("Migration of file: $m, took $d") }
        ).getOrThrow()
        println("Migration completed. $res")
    }

    suspend fun exampleBasics(db: QueryExecutor) {
        println("\n=== Basics ===")
        db.execute("drop table if exists sqlx4k;").getOrThrow()
        db.execute("create table if not exists sqlx4k(id integer, test text);").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (65, 'test');").getOrThrow()

        val rows = db.fetchAll("select * from sqlx4k;", Sqlx4kRowMapper).getOrThrow()
        println("Rows: $rows")

        db.fetchAll("select 1;").getOrThrow().forEach { println(it) }
        db.fetchAll("select now();").getOrThrow().forEach { println(it) }
        db.fetchAll("select 'testtest', 'test1';").getOrThrow().forEach { println(it) }
    }

    suspend fun examplePreparedStatements(db: QueryExecutor) {
        println("\n=== Prepared Statements ===")
        // Ensure data
        db.execute("delete from sqlx4k;").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (65, 'test65'), (66, 'test66');").getOrThrow()

        // Named parameter
        val st1 = Statement
            .create("select * from sqlx4k where id = :id")
            .bind("id", 65)
        val res1 = db.fetchAll(st1, Sqlx4kRowMapper).getOrThrow()
        println("Named params => $res1")

        // Positional parameter
        val st2 = Statement
            .create("select * from sqlx4k where id = ?")
            .bind(0, 66)
        val res2 = db.fetchAll(st2, Sqlx4kRowMapper).getOrThrow()
        println("Positional params => $res2")
    }

    fun exampleStatementBinding() {
        println("\n=== Statement binding ===")
        runCatching {
            val st = Statement.create("select * from sqlx4k where id = ?")
                .bind(0, 65)
                .render()
            println("Statement: $st")

            val st1 = Statement.create("? ? ?")
                .bind(0, "test")
                .bind(1, "'test'")
                .bind(2, "';select *;--")
                .render()
            println("Statement: $st1")
        }.onFailure { println("Statement error: ${it.message}") }
    }

    suspend fun exampleConnectionManagement(db: IMySQL) {
        println("\n=== Connection management ===")
        println("Pool size: ${db.poolSize()} (idle: ${db.poolIdleSize()})")
        val cn: Connection = db.acquire().getOrThrow()
        try {
            println("Acquired connection. Pool size: ${db.poolSize()} (idle: ${db.poolIdleSize()})")
            // Use the dedicated connection
            cn.execute("delete from sqlx4k;").getOrThrow()
            cn.execute("insert into sqlx4k (id, test) values (10, 'from-conn');").getOrThrow()
            val rows = cn.fetchAll("select * from sqlx4k;", Sqlx4kRowMapper).getOrThrow()
            println("Rows via connection: $rows")
        } finally {
            cn.close().getOrThrow()
            delay(1000) // Ensure that the connection has been released.
            println("Released connection. Pool size: ${db.poolSize()} (idle: ${db.poolIdleSize()})")
        }
    }

    suspend fun exampleTransactions(db: IMySQL, repo: Sqlx4kRepository) {
        println("\n=== Transactions ===")
        // Prepare table
        db.execute("delete from sqlx4k;").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (1, 'a');").getOrThrow()

        // Manual begin/rollback
        val tx = db.begin().getOrThrow()
        runCatching {
            tx.execute("insert into sqlx4k (id, test) values (2, 'b');").getOrThrow()
            val inside = repo.findAll(tx).getOrThrow()
            println("Inside manual tx before rollback => $inside")
            error("Force rollback")
        }.onFailure {
            tx.rollback().getOrThrow()
        }
        val afterRollback = repo.findAll(db).getOrThrow()
        println("After rollback => $afterRollback")

        // Using transaction helper (auto-commit)
        db.transaction {
            execute("insert into sqlx4k (id, test) values (3, 'c');").getOrThrow()
            // Demonstrate transactional context by passing `this` (Transaction) to repo
            val inside = repo.findAll(this).getOrThrow()
            println("Inside tx helper => $inside")
        }
        val afterCommit = repo.findAll(db).getOrThrow()
        println("After commit => $afterCommit")
    }

    suspend fun exampleCrudRepository(db: QueryExecutor, repo: Sqlx4kRepository) {
        println("\n=== CrudRepository + @Query ===")

        // Basic seed
        db.execute("delete from sqlx4k;").getOrThrow()
        db.execute("insert into sqlx4k (id, test) values (1, 'a'), (2, 'b'), (3, 'c');").getOrThrow()

        // Use provided repository operations (generated on platforms)
        val found1 = repo.findOneById(db, 2).getOrThrow()
        println("findOneById(2) => $found1")

        val all = repo.findAll(db).getOrThrow()
        println("findAll => ${all.size} items: $all")

        val count = repo.countAll(db).getOrThrow()
        println("countAll => $count")
    }

    suspend fun exampleAutoGeneratedRepository(db: QueryExecutor, repo: Sqlx4kRepository) {
        println("\n=== Auto-generated CRUD ===")

        val inserted = repo.insert(db, Sqlx4k(id = 123456, test = "test")).getOrThrow()
        println("inserted => $inserted")

        val updated = repo.update(db, inserted.copy(test = "updated")).getOrThrow()
        println("updated => $updated")

        val saved = repo.save(db, updated).getOrThrow()
        println("saved => $saved")

        val byId = repo.findOneById(db, 123456).getOrThrow()
        println("findOneById(123456) => $byId")

        repo.delete(db, saved).getOrThrow()
        val afterDelete = repo.findOneById(db, 123456).getOrThrow()
        println("after delete => $afterDelete")
    }

    suspend fun exampleTransactionContext(db: IMySQL) {
        suspend fun doBusinessLogic() {
            val tx = TransactionContext.current()
            tx.execute("update sqlx4k set test = 'tc-updated' where id = 66;").getOrThrow()
            println("doBusinessLogic updated id=66")
        }

        suspend fun doMoreBusinessLogic(): Unit = TransactionContext.withCurrent {
            // Continue in same tx
            fetchAll("select id, test from sqlx4k where id = 66;", Sqlx4kRowMapper).getOrThrow().also {
                println("doMoreBusinessLogic read => $it")
            }
        }

        suspend fun doExtraBusinessLogic(db: IMySQL): Unit = TransactionContext.withCurrent(db) {
            // If no TransactionContext was present, this would open a new tx; here it reuses the existing one
            fetchAll("select count(*) from sqlx4k;").getOrThrow().also {
                println("doExtraBusinessLogic count rows => $it")
            }
        }

        println("\n=== TransactionContext (coroutines) ===")
        TransactionContext.new(db) {
            // Seed a record and demonstrate nested helpers participating in same tx
            execute("insert into sqlx4k (id, test) values (66, 'tc');").getOrThrow()
            println("Inserted id=66 in TransactionContext")
            doBusinessLogic()
            doMoreBusinessLogic()
            doExtraBusinessLogic(db)
        }
        println("TransactionContext block completed")
    }
}
